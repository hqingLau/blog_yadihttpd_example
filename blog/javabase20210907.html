<!DOCTYPE html>
<html lang="zh">

<head>
    <title>Java基础笔记二
- hqinglau的博客 - Orz linux</title>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="sogou_site_verification" content="wEcD18BWjC">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5">
<meta name="description" content="hqinglau的博客，分享Linux，操作系统，编程语言的日志。">
<meta name="keywords" content="Linux,C/C++,个人博客,编程,program,计算机,操作系统">
<meta name="format-detection" content="telephone=no">
<link rel="stylesheet" href="/css/index.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/fontawesome.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery.fancybox@2.1.5/source/jquery.fancybox.css">
<link href="/css/my.css" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/gh/hqinglau/CDN/css/prism.css" rel="stylesheet" />
<style>
  .layui-side {
    position: fixed;
    top: 0;
    background-color: #fff;
    width: 240px;
    margin-left: 10px;
    margin-right: 10px;
    bottom: 0;
  }

  .layui-main {
    margin-top: 40px;
    bottom: 0;
  }

  .header {
    height: 40px;
    width: 100%;
    background-color: #fff;
  }

  .fix-header {
    position: fixed;
    top: 0
  }

  @media screen and (max-device-width:730px) {
    #mySidenav {
      display: none;
    }
  }

  .line {
    width: 100%;
    height: 2px;
    margin: 10px 0;
    overflow: hidden;
    background-color: #eee;
    font-size: 0;
  }
</style>
</head>

<body>
  <script type="text/javascript">
    var ua = navigator.userAgent.toLowerCase();
    var isWeixin = ua.indexOf('micromessenger') != -1;
    if (isWeixin) {
      document.getElementsByTagName('html')[0].innerHTML = "<div style='text-align:right; margin:20px;'>请点击右上角浏览器打开</div><img src='/img/log.jpg' style='display:block;margin:30vh auto;height:20%'></div>";
    }
  </script>
  <script type="text/javascript">
    function openNav() {
      document.getElementById("mySidenav").style.display = "block";

      var windowWidth = document.body.clientWidth;
      if (windowWidth > 700) {
        document.getElementById("mymain").style.marginLeft = "260px";
        document.getElementById("topheader").style.left = "260px";
      }
      else {
        document.getElementById("mymain").style.marginLeft = "0";
      }
      document.getElementById("sidebarbtn").onclick = function () {
        closeNav();
      }

    }

    function closeNav() {
      document.getElementById("mySidenav").style.display = "none";
      document.getElementById("mymain").style.marginLeft = "0";
      document.getElementById("topheader").style.left = "0";
      document.getElementById("sidebarbtn").onclick = function () {
        openNav();
      }

    }
  </script>

  <div>
    <div class="layui-side" id="mySidenav">
      <div class="aside_content" id="aside_content">
        <div class="card-content">
          <div class="card-info-avatar is-center">
            <a href="/">
              <img class="avatar-img" src="https://gitee.com/hqinglau/img/raw/master/logo.jpg" alt="avatar">
            </a>
            <div class="author-info__name">hqinglau的网络日志</div>
            <div class="author-info__description">
              <p>记录Linux, 编程, 操作系统...</p>
            </div>
          </div>
          </br>
        </div>
        <div class="line dk hidden-folded"></div>



        </br>
        <div style="padding-left:50px;">

          <a href="https://orzlinux.cn"
            style="text-decoration:none; color:black;cursor:pointer; font-size:16px; padding-top:5px">
            <span class="fa-stack">
              <i class="fa   fa-lg fa-home fa-stack-1x"></i>
            </span>
            Home
          </a>
          </br>
          <a href="https://github.com/hqinglau"
            style="text-decoration:none; color:black;cursor:pointer; font-size:16px; padding-top:5px">

            <span class="fa-stack">
              <i class="fa  fa-lg fa-github fa-stack-1x"></i>
            </span>
            github
          </a>
          </br>

          <a href="/blog/yadihttpd.html"
            style="text-decoration:none; color:black;cursor:pointer; font-size:16px; padding-top:5px">

            <span class="fa-stack">
              <i class="fa  fa-lg  fa-motorcycle fa-stack-1x"></i>
            </span>
            yadihttpd
          </a>
          </br>
          <a href="/uploadBlog.html"
            style="text-decoration:none; color:black;cursor:pointer; font-size:16px; padding-top:5px">

            <span class="fa-stack">
              <i class="fa  fa-lg  fa-upload fa-stack-1x"></i>
            </span>
            Upload
          </a>
          </br>
          <a href="/blogCategory.html"
            style="text-decoration:none; color:black;cursor:pointer; font-size:16px; padding-top:5px">

            <span class="fa-stack">
              <i class="fa  fa-lg  fa-list fa-stack-1x"></i>
            </span>
            Category
          </a>
          </br>
        </div>




      </div>
    </div>
    <div class="layui-main" id="mymain">
      <div class="header fix-header" id="topheader" style="display:none;">
        <span id="sidebarbtn" style="margin:10px; color: #ccc;font-size:20px;cursor:pointer" onclick="openNav()">&#9776;
        </span>
        <span style="font-size:20px;cursor:pointer;"><a href="https://orzlinux.cn"
            style="text-decoration:none; color:#999; font-size:18px;cursor:pointer;"> hqinglau的博客</a> </span>
      </div>




      <script type="text/javascript">
        var lastW = 0;
        var resizeTimer = null;
        //定义变量获取屏幕视口宽度
        function mywinresize() {

          var windowWidth = document.body.clientWidth;
          if (Math.abs(lastW - windowWidth) < 50) {
            return windowWidth;
          }
          console.log(windowWidth);
          if (windowWidth > 700) {
            openNav();
          }
          else {
            closeNav();
          }
          return windowWidth;
        }
        lastW = mywinresize();
        document.getElementById("topheader").style.display = "block";
        window.addEventListener('resize', function () {
          if (resizeTimer) clearTimeout(resizeTimer);
          resizeTimer = setTimeout(function () {
            lastW = mywinresize();
          }, 500);
        });
      </script>





      <article id="page">
        <div class="article-container">
          <div>
		  <style type="text/css"> img{display:block;margin:0 auto;}</style>
<h1>Java基础笔记二</h1><hr>
<style type="text/css"> img{display:block;margin:0 auto;}</style>

<p>Java <strong>泛型</strong>（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，<strong>该机制允许程序员在编译时检测到非法的类型</strong>。Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说<strong>类型擦除</strong> 。</p>
<p>实现泛型接口可以指定或不指定泛型。</p>
<p><strong>泛型</strong>可以通过反射绕过：</p>
<pre><code class="language-java">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(10);
//list.add(&quot;12&quot;); // 报错
Class&lt;? extends List&gt; cl = list.getClass();
Method add = cl.getDeclaredMethod(&quot;add&quot;, Object.class);
add.invoke(list,&quot;k1&quot;);
System.out.println(list);  // [10, k1]
</code></pre>
<p><strong><code>equals()</code></strong> 方法存在两种使用情况：</p>
<ul>
<li>类没有覆盖 <code>equals()</code>方法 ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li>类覆盖了 <code>equals()</code>方法 ：一般我们都覆盖 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<p><strong>重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法</strong>：</p>
<p>哈希碰撞，碰撞了说明 hashcode 一样了，但是对象不一定相等。但是例如 <code>HashSet</code>是先检查 hashCode 再比较的（减少<code>equals</code>调用次数），所以需要重写<code>hashCode</code> 方法。</p>
<p><strong>基本类型</strong>：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>位数</th>
<th>字节</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td>32</td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td><code>short</code></td>
<td>16</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td><code>long</code></td>
<td>64</td>
<td>8</td>
<td>0L</td>
</tr>
<tr>
<td><code>byte</code></td>
<td>8</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><code>char</code></td>
<td>16</td>
<td>2</td>
<td>&#39;u0000&#39;</td>
</tr>
<tr>
<td><code>float</code></td>
<td>32</td>
<td>4</td>
<td>0f</td>
</tr>
<tr>
<td><code>double</code></td>
<td>64</td>
<td>8</td>
<td>0d</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>1</td>
<td></td>
<td>false</td>
</tr>
</tbody></table>
<p><code>boolean</code> 考虑计算机高效存储因素，依赖 JVM 厂商实现。</p>
<p><strong>包装类和常量池</strong>：</p>
<p>Java 基本类型的包装类的大部分都实现了常量池技术。<code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在[0,127]范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> Or <code>False</code>。两种浮点数类型的包装类 <code>Float</code>, <code>Double</code> 没有实现常量池技术。</p>
<pre><code class="language-java">Integer i1 = 10;  // 装箱
Integer i2 = new Integer(10);
Integer i3 = Integer.valueOf(10);
System.out.println(i1==i2); // false
System.out.println(i1==i3); // true
</code></pre>
<blockquote>
<p>对象不要用==直接比较。</p>
</blockquote>
<p><strong>静态方法</strong>在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法）。</p>
<p><strong>Java 程序设计语言总是采用按值调用。</strong>也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。传递的是对象引用的拷贝。</p>
<img src="https://gitee.com/hqinglau/img/raw/master/img/20210907105609.png" alt="image-20210907105609428" style="zoom:80%;" />

<blockquote>
<p>C++的引用传递是给 arr 取别名，不拷贝。意思就是 Java 不搞别名这一套。</p>
</blockquote>
<p><strong>重载</strong>：overloading，多个方法有相同的名字不同的参数。</p>
<p><strong>重写</strong>：override，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<p>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。构造方法无法被重写。<strong>如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</strong>构造方法不能重写。</p>
<p><strong>面向对象三大特征</strong>：封装、继承、多态（父类的引用指向子类的实例）。</p>
<p><code>String</code>不可变，<code>final</code>。<code>StringBuffer</code>（加了同步锁，线程安全）和<code>StringBuilder</code>（非线程安全）可变。</p>
<p><strong>反射</strong>之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。</p>
<p>当我们不想访问或者不能直接访问一个对象的时候，我们就需要用到<strong>代理模式</strong>。</p>
<p>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后可以增加一些自定义的操作。动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p>
<p>例子：</p>
<pre><code class="language-java">interface Animal {
    void eat();
}
class Pig implements Animal{

    @Override
    public void eat() {
        System.out.println(&quot;Pig eating...&quot;);
    }
}
</code></pre>
<p>静态代理：</p>
<pre><code class="language-java">class StaticProxy implements Animal {
    private Animal animal;
    StaticProxy(Animal ani) {
        this.animal = ani;
    }

    @Override
    public void eat() {
        animal.eat();
    }
}
public class Test {
    public static void main(String[] args) {
        Animal animal = new StaticProxy(new Pig());
        animal.eat();
    }
}
</code></pre>
<p><strong>动态代理</strong>：</p>
<p>JDK:</p>
<pre><code class="language-java">class DynamicProxy implements InvocationHandler {
    private Object object;
    public DynamicProxy(Object obj) {
        this.object = obj;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object result = method.invoke(object,args);
        return result;
    }
}

public class HelloWorld {
    public static void main(String[] args) {
        Animal animal = new Pig();
        Animal dynamicProxy = (Animal) Proxy.newProxyInstance(
                animal.getClass().getClassLoader(),
                animal.getClass().getInterfaces(),
                new DynamicProxy(animal)
        );
        dynamicProxy.eat();
    }
}
</code></pre>
<p>Java 标准库提供了动态代理功能，允许在运行期动态创建一个接口的实例：</p>
<pre><code class="language-java">interface Animal {
    void eat(String food);
}

public class Test {
    public static void main(String[] args) {
        InvocationHandler handler = new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println(method);
                if(method.getName().equals(&quot;eat&quot;)) {
                    System.out.println(&quot;Pig eat &quot;+args[0]);
                }
                return null;
            }
        };
        Animal dynamicProxy = (Animal) Proxy.newProxyInstance(
                Animal.class.getClassLoader(),
                new Class[] {Animal.class},
                handler
        );
        dynamicProxy.eat(&quot;yadi&quot;);
    }
}

// 输出：
// public abstract void Animal.eat(java.lang.String)
// Pig eat yadi
</code></pre>
<p><strong>静态代理和动态代理的对比</strong>：</p>
<p>灵活性 ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</p>
<p>JVM 层面：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</p>
<p><strong>使用 == 比较枚举类型</strong></p>
<p><strong>反射</strong>：</p>
<p>通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制，动态代理的实现也依赖反射。</p>
<pre><code class="language-java">class Pig {
    private String name;
    public Pig() {
        name = &quot;Pig&quot;;
    }
    public void eat(String s) {
        System.out.println(&quot;public pig eat &quot;+s);
    }
    private void run() {
        System.out.println(&quot;running...&quot;);
    }
}

public class HelloWorld {
    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {
        Class&lt;?&gt; pigClass = Class.forName(&quot;Pig&quot;);
        Pig pig = (Pig)pigClass.getDeclaredConstructor().newInstance();
        /**
         * 获取类中所有方法
         */
        for(Method method:pigClass.getDeclaredMethods()) {
            System.out.println(method.getName());
        }
        /**
         * 调用指定方法
         */
        Method eat = pigClass.getDeclaredMethod(&quot;eat&quot;,  String.class);
        eat.invoke(pig,&quot;food&quot;);

        /**
         * 修改参数
         */
        Field field = pigClass.getDeclaredField(&quot;name&quot;);
        // 取消安全检查
        field.setAccessible(true);
        field.set(pig,&quot;pepe&quot;);

        /**
         * 调用private方法
         */
        Method run = pigClass.getDeclaredMethod(&quot;run&quot;);
        // 为了调用private方法取消安全检查
        // 不然会报错
        // class HelloWorld cannot access a member
        // of class Pig with modifiers &quot;private&quot;
        run.setAccessible(true);
        run.invoke(pig);
    }
}
// 输出
/**
 * run
 * eat
 * public pig eat food
 * running...
 */
</code></pre>
<p><strong>IO</strong>：</p>
<p>Java 中常见三种 IO 模型：BIO（Blocking I/O）、NIO（Non-Blocking/New I/O）、AIO（Asynchronous I/O）。</p>
<p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。</p>
<blockquote>
<p>Java的NIO（new IO）技术，使用的就是IO多路复用模型。在linux系统上，使用的是epoll系统调用。</p>
<p><strong>多路复用IO</strong>的缺点：本质上，select/epoll系统调用，属于同步IO，也是阻塞IO。都需要<strong>在读写事件就绪后</strong>，自己负责进行读写，也就是说这个<strong>读写过程是阻塞</strong>的。</p>
<p>本博客后台 yadihttpd 为多路复用IO。</p>
</blockquote>
<img src="https://gitee.com/hqinglau/img/raw/master/img/20210907140642.png" alt="image-20210907140642358"  />



<p><strong>参考</strong>：</p>
<p><a href="https://snailclimb.gitee.io/javaguide/">JavaGuide</a></p>
<p><a href="https://www.cnblogs.com/crazymakercircle/p/10225159.html">10 分钟看懂， Java NIO 底层原理</a></p>
</div>


</div>
<br>
<div id="banquan-yadi" style="display:none">
	<blockquote style="line-height:1.2;padding-bottom:10px;">
		<p>本文地址:
			<a href="https://orzlinux.cn" id="blogaddr-a" style="text-decoration:none; color:black;cursor:pointer;">
				hqinglau的博客</a>
		</p>
		<p>作者:
			<a href="https://orzlinux.cn" style="text-decoration:none; color:black;cursor:pointer;">
				hqinglau
			</a>
		</p>
		<p>博客地址:
			<a href="https://orzlinux.cn" style="text-decoration:none; color:black;cursor:pointer;">
				https://orzlinux.cn
			</a>
		</p>

		<p>版权说明: 如无注明，本文皆由
			<a href="https://orzlinux.cn" style="text-decoration:none; color:black;cursor:pointer;">
				hqinglau
			</a>原创，转载请保留文章出处
		</p>
	</blockquote>
</div>
</article>
</div>
<div id="footer-wrap">
	<div class="copyright">Powered by <a style="color:#4c4948;text-decoration:none;" href="https://github.com/hqinglau/yadihttpd">yadihttpd</a>
		|
			<a style="color:#4c4948;text-decoration:none;" href="https://orzlinux.cn/sitemap.xml">sitemap</a>

		| 
		<a href="https://www.cnzz.com/stat/website.php?web_id=1280379355" style="color:#4c4948;text-decoration:none;" target="_blank" title="站长统计">网站统计</a>
		</div>
	<div class="copyright">Copyright © 2021 hqinglau</div>
	<div style="width:300px;margin:0 auto; padding:5px 0;">
		<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41022102001049"
			style="display:inline-block;text-decoration:none;height:20px;line-height:20px;"><img
				src="https://orzlinux.cn/img/beian.png" style="float:left;">
			<p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;">豫公网安备
				41022102001049号</p>
		</a>
	</div>
</div>
</div>
<script src="https://cdn.jsdelivr.net/gh/hqinglau/CDN/js/prism.js"></script>

<!-- 看板娘 -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
<script type="text/javascript">document.write(unescape("%3Cspan style='display:none;' id='cnzz_stat_icon_1280379355'%3E%3C/span%3E%3Cscript src='https://s4.cnzz.com/z_stat.php%3Fid%3D1280379355' type='text/javascript'%3E%3C/script%3E"));</script>
<script>
	(function(){
	var el = document.createElement("script");
	el.src = "https://lf1-cdn-tos.bytegoofy.com/goofy/ttzz/push.js?b49908f94659486112caf80ce9c79f8438025d2d666f8d5952ffe1da06a881cb30632485602430134f60bc55ca391050b680e2741bf7233a8f1da9902314a3fa";
	el.id = "ttzz";
	var s = document.getElementsByTagName("script")[0];
	s.parentNode.insertBefore(el, s);
	})(window)
</script>
<script>
	(function(){
	var src = "https://s.ssl.qhres2.com/ssl/ab77b6ea7f3fbf79.js";
	document.write('<script src="' + src + '" id="sozz"><\/script>');
	})();
</script>
<script>
	(function(){
		var bp = document.createElement('script');
		var curProtocol = window.location.protocol.split(':')[0];
		if (curProtocol === 'https'){
	   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
	  }
	  else{
	  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	  }
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(bp, s);
	})();
</script>
				<script type="text/javascript">
				document.getElementById("banquan-yadi").style.display ="";
			document.getElementById("blogaddr-a").href ="https://orzlinux.cn/blog/"+"javabase20210907.html";
			document.getElementById("blogaddr-a").innerHTML="Java基础笔记二";
			</script></body></html> 

<!DOCTYPE html>
<html lang="zh">

<head>
    <title>数据结构-树
- hqinglau的博客 - Orz linux</title>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="sogou_site_verification" content="wEcD18BWjC">
<meta name="referrer" content="no-referrer" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5">
<meta name="description" content="hqinglau的博客，分享Linux，操作系统，编程语言的日志。">
<meta name="keywords" content="Linux,C/C++,个人博客,编程,program,计算机,操作系统">
<meta name="format-detection" content="telephone=no">
<link rel="stylesheet" href="/css/index.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/fontawesome.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery.fancybox@2.1.5/source/jquery.fancybox.css">
<link href="/css/my.css" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/gh/hqinglau/CDN/css/prism.css" rel="stylesheet" />
<style>
  .layui-side {
    position: fixed;
    top: 0;
    background-color: #fff;
    width: 240px;
    margin-left: 10px;
    margin-right: 10px;
    bottom: 0;
  }

  .layui-main {
    margin-top: 40px;
    bottom: 0;
  }

  .header {
    height: 40px;
    width: 100%;
    background-color: #fff;
  }

  .fix-header {
    position: fixed;
    top: 0
  }

  @media screen and (max-device-width:730px) {
    #mySidenav {
      display: none;
    }
  }

  .line {
    width: 100%;
    height: 2px;
    margin: 10px 0;
    overflow: hidden;
    background-color: #eee;
    font-size: 0;
  }
</style>
</head>

<body>
  <script type="text/javascript">
    var ua = navigator.userAgent.toLowerCase();
    var isWeixin = ua.indexOf('micromessenger') != -1;
    if (isWeixin) {
      document.getElementsByTagName('html')[0].innerHTML = "<div style='text-align:right; margin:20px;'>请点击右上角浏览器打开</div><img src='/img/log.jpg' style='display:block;margin:30vh auto;height:20%'></div>";
    }
  </script>
  <script type="text/javascript">
    function openNav() {
      document.getElementById("mySidenav").style.display = "block";

      var windowWidth = document.body.clientWidth;
      if (windowWidth > 700) {
        document.getElementById("mymain").style.marginLeft = "260px";
        document.getElementById("topheader").style.left = "260px";
      }
      else {
        document.getElementById("mymain").style.marginLeft = "0";
      }
      document.getElementById("sidebarbtn").onclick = function () {
        closeNav();
      }

    }

    function closeNav() {
      document.getElementById("mySidenav").style.display = "none";
      document.getElementById("mymain").style.marginLeft = "0";
      document.getElementById("topheader").style.left = "0";
      document.getElementById("sidebarbtn").onclick = function () {
        openNav();
      }

    }
  </script>

  <div>
    <div class="layui-side" id="mySidenav">
      <div class="aside_content" id="aside_content">
        <div class="card-content">
          <div class="card-info-avatar is-center">
            <a href="/">
              <img class="avatar-img" src="https://gitee.com/hqinglau/img/raw/master/logo.jpg" alt="avatar">
            </a>
            <div class="author-info__name">hqinglau的网络日志</div>
            <div class="author-info__description">
              <p>记录Linux, 编程, 操作系统...</p>
            </div>
          </div>
          </br>
        </div>
        <div class="line dk hidden-folded"></div>



        </br>
        <div style="padding-left:50px;">

          <a href="https://orzlinux.cn"
            style="text-decoration:none; color:black;cursor:pointer; font-size:16px; padding-top:5px">
            <span class="fa-stack">
              <i class="fa   fa-lg fa-home fa-stack-1x"></i>
            </span>
            Home
          </a>
          </br>
          <a href="https://github.com/hqinglau"
            style="text-decoration:none; color:black;cursor:pointer; font-size:16px; padding-top:5px">

            <span class="fa-stack">
              <i class="fa  fa-lg fa-github fa-stack-1x"></i>
            </span>
            github
          </a>
          </br>

          <a href="/blog/yadihttpd.html"
            style="text-decoration:none; color:black;cursor:pointer; font-size:16px; padding-top:5px">

            <span class="fa-stack">
              <i class="fa  fa-lg  fa-motorcycle fa-stack-1x"></i>
            </span>
            yadihttpd
          </a>
          </br>
          <a href="/uploadBlog.html"
            style="text-decoration:none; color:black;cursor:pointer; font-size:16px; padding-top:5px">

            <span class="fa-stack">
              <i class="fa  fa-lg  fa-upload fa-stack-1x"></i>
            </span>
            Upload
          </a>
          </br>
          <a href="/blogCategory.html"
            style="text-decoration:none; color:black;cursor:pointer; font-size:16px; padding-top:5px">

            <span class="fa-stack">
              <i class="fa  fa-lg  fa-list fa-stack-1x"></i>
            </span>
            Category
          </a>
          </br>
        </div>




      </div>
    </div>
    <div class="layui-main" id="mymain">
      <div class="header fix-header" id="topheader" style="display:none;">
        <span id="sidebarbtn" style="margin:10px; color: #ccc;font-size:20px;cursor:pointer" onclick="openNav()">&#9776;
        </span>
        <span style="font-size:20px;cursor:pointer;"><a href="https://orzlinux.cn"
            style="text-decoration:none; color:#999; font-size:18px;cursor:pointer;"> hqinglau的博客</a> </span>
      </div>




      <script type="text/javascript">
        var lastW = 0;
        var resizeTimer = null;
        //定义变量获取屏幕视口宽度
        function mywinresize() {

          var windowWidth = document.body.clientWidth;
          if (Math.abs(lastW - windowWidth) < 50) {
            return windowWidth;
          }
          console.log(windowWidth);
          if (windowWidth > 700) {
            openNav();
          }
          else {
            closeNav();
          }
          return windowWidth;
        }
        lastW = mywinresize();
        document.getElementById("topheader").style.display = "block";
        window.addEventListener('resize', function () {
          if (resizeTimer) clearTimeout(resizeTimer);
          resizeTimer = setTimeout(function () {
            lastW = mywinresize();
          }, 500);
        });
      </script>





      <article id="page">
        <div class="article-container">
          <div>
		  <style type="text/css"> img{display:block;margin:0 auto;}</style>
<h1>数据结构-树</h1><hr>
<h2 id="一、回顾基本概念">一、回顾基本概念</h2>
<h3 id="树">树</h3>
<p><img src="https://gitee.com/hqinglau/img/raw/master/img/20211020095334.png" alt="image-20211020095334628"></p>
<p>每个结点有<strong>零或多</strong>个子节点，没有父结点的结点后称为<strong>根结点</strong>，除了根结点每个子结点可以分为多个不相交的子树。</p>
<p><strong>结点层次</strong>：根结点为第一层，其子结点为第二层，依次递推</p>
<p><strong>结点深度</strong>：从根结点向下累加</p>
<p><strong>结点高度</strong>：从叶结点向上累加</p>
<p><strong>树的高度</strong>：为结点最大层数，图中为5</p>
<p><strong>森林</strong>：互不相交的树的集合（把根节点去掉就是森林了）</p>
<h3 id="二叉树">二叉树</h3>
<p>每个结点最多有两棵子树，且结点有左右之分。二叉树的左子树和右子树也是二叉树。根据二叉树的状态又有几个特殊的子树。</p>
<h4 id="斜二叉树">斜二叉树</h4>
<p><img src="https://gitee.com/hqinglau/img/raw/master/img/20211020100616.png" alt="image-20211020100616872"></p>
<p>这也是后续要尽量避免的情形，失去了树的意义。</p>
<h4 id="满二叉树">满二叉树</h4>
<p>高度<code>h</code>，则结点为<code>2h-1</code>的树为满二叉树，也就是每一层都是满的。</p>
<p><img src="https://gitee.com/hqinglau/img/raw/master/img/20211020100944.png" alt="image-20211020100944283"></p>
<h4 id="完全二叉树">完全二叉树</h4>
<p>不一定满，只有最后一层可能不满，且不会有间隔。</p>
<p><img src="https://gitee.com/hqinglau/img/raw/master/img/20211020101222.png" alt="image-20211020101215620"></p>
<h4 id="二叉查找树">二叉查找树</h4>
<p>别名：二叉搜索树、二叉排序树、BST</p>
<p>一个结点A，左边结点要么为空，要么小于结点A；右边结点要么为空，要么大于结点A。没有键值相等的结点。</p>
<p>上图就是一个二叉查找树。</p>
<h4 id="平衡二叉树">平衡二叉树</h4>
<p>特殊的二叉搜索树，一个结点左右子树高度差不超过1。上图其实还是一个平衡二叉树。</p>
<h2 id="二、二叉树的遍历">二、二叉树的遍历</h2>
<h3 id="存储方式">存储方式</h3>
<p>二叉树的存储有如下方法：</p>
<p><strong>数组</strong>：适合完全二叉树，普通的二叉树（可能是斜二叉树）空间浪费大。</p>
<p><strong>父结点指针</strong>、<strong>子结点指针</strong>。本文选用子结点指针。</p>
<pre><code class="language-java">class Node {
    int data;
    Node left;
    Node right;
}
</code></pre>
<h3 id="前、中、后序遍历">前、中、后序遍历</h3>
<blockquote>
<p><strong>先序：</strong>考察到一个节点后，即刻输出该节点的值，并继续遍历其左右子树。(根左右)</p>
<p><strong>中序：</strong>考察到一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。(左根右)</p>
<p><strong>后序：</strong>考察到一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值。(左右根)</p>
</blockquote>
<p><strong>以二叉查找树为例</strong>。BST首先应该有根结点和插入方法。二叉查找树插入：小于当前结点插入左边，否则右边。</p>
<pre><code class="language-java">public class BST {
    // 根结点
    Node root = null;
    // 插入二叉搜索树
    public boolean insert(int data) {
        if(root==null) {
            root = new Node(data);
            return true;
        }
        Node n = root;
        while (true) {
            if (data&lt;n.data) {
                if(n.left==null) {
                    n.left = new Node(data);
                    return true;
                } else {
                    n = n.left;
                }
            }
            else if(data == n.data) { // BST没有键值相等的
                return false;
            }
            else {
                if(n.right==null) {
                    n.right = new Node(data);
                    return true;
                } else {
                    n = n.right;
                }
            }
        }
    }
}
</code></pre>
<p>遍历接口，选择前中后序遍历。</p>
<pre><code class="language-java">public void traverse(String method) {
    switch (method) {
        case &quot;preOrder&quot;:
            preOrderTraverse(root);
            break;
        case &quot;postOrder&quot;:
            postOrderTraverse(root);
            break;
        case &quot;inOrder&quot;:
            inOrderTraverse(root);
            break;
        default:
            System.out.println(&quot;preOrder、postOrder、inOrder，输入无效，按preOrder非递归遍历&quot;);
            preOrderTraverse();
    }
}
</code></pre>
<p>测试插入：</p>
<pre><code class="language-java">public static void main(String[] args) {
    BST bst = new BST();
    bst.insert(3);
    bst.insert(6);
    bst.insert(9);
    bst.insert(2);
    bst.insert(1);
    bst.insert(10);
    bst.insert(7);
    bst.traverse(&quot;inOrder&quot;); // 1 2 3 6 7 9 10
}
</code></pre>
<p>如图：</p>
<p><img src="https://gitee.com/hqinglau/img/raw/master/img/20211020113408.png" alt="image-20211020113408623"></p>
<h4 id="前序遍历">前序遍历</h4>
<p>考察到一个节点后，即刻输出该节点的值，并继续遍历其左右子树。(根左右)</p>
<p>递归方法比较明了，如下：</p>
<pre><code class="language-java">private void preOrderTraverse(Node n) {
    if(n==null) {
        return;
    }
    System.out.println(n.data);
    preOrderTraverse(n.left);
    preOrderTraverse(n.right);
}
</code></pre>
<p>非递归方法：输出一个结点的值后，要遍历其左子树，完了之后还要回来遍历它的右子树，所以应该有个栈存放遍历过的结点。</p>
<p>非递归方法：</p>
<pre><code class="language-java">private void preOrderTraverse() {
    if(root==null) {
        return;
    }
    Stack&lt;Node&gt; stack = new Stack&lt;&gt;();
    System.out.println(root.data); // 输出
    stack.push(root); // 压栈，遍历左子树，完了弹出栈，遍历右子树
    Node cur = root;
    while(true) {
        if(cur.left!=null) {
            System.out.println(cur.left.data);
            stack.push(cur.left);
            cur = cur.left;
        }
        else {
            do {
                if(stack.empty()) {
                    return;
                }
                cur = stack.pop().right;
            } while (cur==null);
            System.out.println(cur.data);
            stack.push(cur);
        }
    }
}
</code></pre>
<p>如图：</p>
<p><img src="https://gitee.com/hqinglau/img/raw/master/img/20211020131428.png" alt="image-20211020131428109"></p>
<h4 id="中序遍历">中序遍历</h4>
<p>考察到一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。(左根右)</p>
<p>递归方法：</p>
<pre><code class="language-java">private void inOrderTraverse(Node n) {
    if(n==null) {
        return;
    }
    inOrderTraverse(n.left);
    System.out.println(n.data);
    inOrderTraverse(n.right);
}
</code></pre>
<p>非递归方法：</p>
<pre><code class="language-java">private void inOrderTraverse() {
    if(root==null) {
        return;
    }
    Stack&lt;Node&gt; stack = new Stack&lt;&gt;();
    stack.push(root); // 压栈，遍历左子树，打印当前结点，完了弹出栈，遍历右子树
    Node cur = root;
    while(true) {
        if(cur.left!=null) {
            stack.push(cur.left);
            cur = cur.left;
        }
        else {
            do {
                if(stack.empty()) {
                    return;
                }
                Node n = stack.pop();
                System.out.println(n.data);
                cur = n.right;
            } while (cur==null);
            stack.push(cur);
        }
    }
}
</code></pre>
<h4 id="后序遍历">后序遍历</h4>
<p>递归方法：</p>
<pre><code class="language-java">private void postOrderTraverse(Node n) {
    if(n==null) {
        return;
    }
    postOrderTraverse(n.left);
    postOrderTraverse(n.right);
    System.out.println(n.data);
}
</code></pre>
<h3 id="层序遍历">层序遍历</h3>
<p>用队列存一层的结点。读的时候从头依次读取，左右子结点依次存取。</p>
<pre><code class="language-java">public void levelOrderTraverse() {
    if(root==null) {
        return;
    }
    Queue&lt;Node&gt; stack = new LinkedList&lt;&gt;();
    stack.add(root); // 压栈，遍历左子树，完了弹出栈，遍历右子树

    int lastLayer = 1;
    int n = 0;
    while(!stack.isEmpty()) {
        for(int i=0;i&lt;lastLayer;i++) {
            Node node = stack.poll();
            System.out.println(node.data);
            if(node.left!=null) {
                n++;
                stack.add(node.left);
            }
            if(node.right!=null) {
                n++;
                stack.add(node.right);
            }
        }
        lastLayer = n;
        n = 0;
    }
}
</code></pre>
<h2 id="三、二叉搜索树">三、二叉搜索树</h2>
<h3 id="二叉搜索树">二叉搜索树</h3>
<h4 id="插入">插入</h4>
<p>见第二节的存储方式部分。</p>
<h4 id="删除">删除</h4>
<p>如要删除6结点</p>
<img src="https://gitee.com/hqinglau/img/raw/master/img/20211020160635.png" alt="image-20211020160635608" style="zoom:80%;" />

<p>按照递归思路比较容易，找到了就处理，找不到就分配给子函数处理。找到之后，如果是左树为空或右树为空，直接挂上，都不为空需要找到右子树的最小结点，赋值给根结点，然后删除最小结点。</p>
<pre><code class="language-java">private Node remove(Node r, int data) {
    if(r==null) return null;
    if(data&gt;r.data) {
        r.right = remove(r.right,data);
    } else if(data&lt;r.data) {
        r.left = remove(r.left,data);
    } else { // root 的data == data
        if(r.left==null) {
            r = r.right;
        } else if (r.right == null) {
            r = r.left;
        } else { // 把右子树最小结点提到根结点，然后删除这个最小结点
            Node minNode = r.right;
            while(minNode.left!=null) {
                minNode = minNode.left;
            }
            r.data = minNode.data;
            r.right = remove(r.right,minNode.data);
        }
    }
    return r;
}
</code></pre>
<h4 id="查找">查找</h4>
<p>小往左子树找，大往右子树找。最大查找时间为树的高度。</p>
<h3 id="平衡二叉树-1">平衡二叉树</h3>
<p>普通二叉搜索树问题：极端情况会退化成线性。</p>
<p><img src="https://gitee.com/hqinglau/img/raw/master/img/20211020133555.png" alt="image-20211020133555445"></p>
<p>平衡二叉树在修改时借助<strong>旋转操作</strong>，左右子树高度差不超过1，避免了这一问题。如图所示，要在该树种插入9，会破坏平衡：</p>
<p><img src="https://gitee.com/hqinglau/img/raw/master/img/20211020163052.png" alt="image-20211020163051980"></p>
<h4 id="旋转">旋转</h4>
<p><img src="https://gitee.com/hqinglau/img/raw/master/img/20211020164728.png" alt="image-20211020164728884"></p>
<p>左旋：以<strong>右子树结点为轴</strong>，动左边的x结点，旋转过程接收y的左子树作为右结点。右旋同理。</p>
<p>上图中，左旋之后，a的深度+1，c的深度-1。所以：<strong>可以通过合适的左旋和右旋操作，调整二叉树的深度。</strong></p>
<h4 id="ll插入">LL插入</h4>
<p>对的左儿子的左子树进行一次插入（左左）：根结点右旋</p>
<p><img src="https://gitee.com/hqinglau/img/raw/master/img/20211020165340.png" alt="image-20211020165340908"></p>
<h4 id="lr插入">LR插入</h4>
<p>LR问题，对根结点左儿子右子树的插入问题：</p>
<img src="https://gitee.com/hqinglau/img/raw/master/img/20211020172401.png" alt="image-20211020172401514" style="zoom:80%;" />

<h4 id="rr插入">RR插入</h4>
<p>LL插入的镜像问题，右边可能过深，对整体来一次左旋。</p>
<h4 id="rl插入">RL插入</h4>
<p>LR问题的镜像问题，先对右子树右旋，再整体左旋。</p>
<h4 id="代码实现">代码实现</h4>
<p>按常规插入后调整。</p>
<pre><code class="language-java">public class AVL {
    Node root;

    public int getHeight(Node r) {
        if (r == null) return 0;
        return Math.max(getHeight(r.left), getHeight(r.right)) + 1;
    }

    public Node rotateLeft(Node r) {
        Node t = r.right;
        r.right = t.left;
        t.left = r;
        return t;
    }

    public Node rotateRight(Node r) {
        Node t = r.left;
        r.left = t.right;
        t.right = r;
        return t;
    }

    public void insert(int data) {
        root = insert(root,data);
        Node left = root.left;
        Node right = root.right;
        if(left!=null) {
            if(getHeight(left.left)-getHeight(left.right)&gt;=2) {
                root.left =  rotateRight(left);
            } else if(getHeight(left.right)-getHeight(left.left)&gt;=2) {
                root.left = rotateLeft(left);
            }
        }
        if(right!=null) {
            if(getHeight(right.left)-getHeight(right.right)&gt;=2) {
                root.right=rotateRight(right);
            } else if(getHeight(right.right)-getHeight(right.left)&gt;=2) {
                root.right=rotateLeft(right);
            }
        }
        if(getHeight(left)-getHeight(right)&gt;=2) {
            root=rotateRight(root);
        }  else if(getHeight(right)-getHeight(left)&gt;=2) {
            root=rotateLeft(root);
        }
    }

    public Node insert(Node r, int data) {
        if (r == null) {
            return new Node(data);
        }
        if (data &gt; r.data) {
            r.right = insert(r.right, data);
        } else if (data &lt; r.data) {
            r.left = insert(r.left, data);
        }
        return r;
    }
}
</code></pre>
<h2 id="四、红黑树简述">四、红黑树简述</h2>
<img src="https://gitee.com/hqinglau/img/raw/master/img/20211020201047.png" alt="image-20211020201047683" style="zoom:80%;" />

<p><strong>有了平衡二叉树，为何还要红黑树？</strong></p>
<p>AVL插入时，几乎都需要旋转操作维持平衡。红黑树牺牲严格的平衡，换取插入/删除时的性能。</p>
<h3 id="红黑树规则">红黑树规则</h3>
<p>规则一：结点非黑即红</p>
<p>规则二：根结点为黑色</p>
<p>规则三：叶结点的子结点（null）为黑色</p>
<p>规则四：红色结点的子结点为黑色</p>
<p>规则五：每个结点到null结点的所有路径，包含相同数目的黑色结点（相同的黑色高度）</p>
<p>如上图中<code>17</code>到<code>nil</code>结点，黑色结点数都是2。</p>
<p>这5条约束保证了：<strong>从根结点到叶子结点的最长路径，不会超过最短路径的两倍</strong>。由规则5具有相同的黑色高度，最短路径就全是黑色，最长路径黑红相间，而红色子结点为黑色，即不大于最短路径的两倍。</p>
<h3 id="三种变换">三种变换</h3>
<p>插入后不破坏规则，不需要旋转变色，破坏规则需要调整。</p>
<p><img src="https://gitee.com/hqinglau/img/raw/master/img/20211020203100.png" alt="image-20211020203100266"></p>
<h4 id="变色">变色</h4>
<p>插入结点一般选择红色，因为黑色由于规则五：相同黑色高度问题，很难调整。红红相连问题可通过变色和旋转解决。</p>
<h4 id="左旋">左旋</h4>
<img src="https://gitee.com/hqinglau/img/raw/master/img/20211020203330.png" alt="image-20211020203330311" style="zoom:80%;" />

<p>和之前的平衡二叉树左旋、右旋是一样的。</p>
<h4 id="右旋">右旋</h4>
<img src="https://gitee.com/hqinglau/img/raw/master/img/20211020203437.png" alt="image-20211020203437203" style="zoom:80%;" />





<h2 id="参考文献">参考文献</h2>
<p><a href="https://www.jianshu.com/p/456af5480cee">二叉树遍历(先序、中序、后序)</a></p>
<p><a href="https://blog.csdn.net/Real_Fool_/article/details/113930623">数据结构：树(Tree)【详解】</a></p>
<p><a href="https://blog.csdn.net/weixin_42208959/article/details/108065466">数据结构和算法可视化工具</a></p>
<p><a href="https://blog.csdn.net/qq_24336773/article/details/81712866">平衡二叉树（树的旋转）</a></p>
<p><a href="https://visualgo.net/en">https://visualgo.net/en</a></p>
<p><a href="https://blog.csdn.net/u014454538/article/details/120120216">红黑树详解</a></p>
</div>


</div>
<br>
<div id="banquan-yadi" style="display:none">
	<blockquote style="line-height:1.2;padding-bottom:10px;">
		<p>本文地址:
			<a href="https://orzlinux.cn" id="blogaddr-a" style="text-decoration:none; color:black;cursor:pointer;">
				hqinglau的博客</a>
		</p>
		<p>作者:
			<a href="https://orzlinux.cn" style="text-decoration:none; color:black;cursor:pointer;">
				hqinglau
			</a>
		</p>
		<p>博客地址:
			<a href="https://orzlinux.cn" style="text-decoration:none; color:black;cursor:pointer;">
				https://orzlinux.cn
			</a>
		</p>

		<p>版权说明: 如无注明，本文皆由
			<a href="https://orzlinux.cn" style="text-decoration:none; color:black;cursor:pointer;">
				hqinglau
			</a>原创，转载请保留文章出处
		</p>
	</blockquote>
</div>
</article>
</div>
<div id="footer-wrap">
	<div class="copyright">Powered by <a style="color:#4c4948;text-decoration:none;" href="https://github.com/hqinglau/yadihttpd">yadihttpd</a>
		|
			<a style="color:#4c4948;text-decoration:none;" href="https://orzlinux.cn/sitemap.xml">sitemap</a>

		| 
		<a href="https://www.cnzz.com/stat/website.php?web_id=1280379355" style="color:#4c4948;text-decoration:none;" target="_blank" title="站长统计">网站统计</a>
		</div>
	<div class="copyright">Copyright © 2021 hqinglau</div>
	<div style="width:300px;margin:0 auto; padding:5px 0;">
		<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41022102001049"
			style="display:inline-block;text-decoration:none;height:20px;line-height:20px;"><img
				src="https://orzlinux.cn/img/beian.png" style="float:left;">
			<p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;">豫公网安备
				41022102001049号</p>
		</a>
	</div>
</div>
</div>
<script src="https://cdn.jsdelivr.net/gh/hqinglau/CDN/js/prism.js"></script>

<!-- 看板娘 -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
<script type="text/javascript">document.write(unescape("%3Cspan style='display:none;' id='cnzz_stat_icon_1280379355'%3E%3C/span%3E%3Cscript src='https://s4.cnzz.com/z_stat.php%3Fid%3D1280379355' type='text/javascript'%3E%3C/script%3E"));</script>
<script>
	(function(){
	var el = document.createElement("script");
	el.src = "https://lf1-cdn-tos.bytegoofy.com/goofy/ttzz/push.js?b49908f94659486112caf80ce9c79f8438025d2d666f8d5952ffe1da06a881cb30632485602430134f60bc55ca391050b680e2741bf7233a8f1da9902314a3fa";
	el.id = "ttzz";
	var s = document.getElementsByTagName("script")[0];
	s.parentNode.insertBefore(el, s);
	})(window)
</script>
<script>
	(function(){
	var src = "https://s.ssl.qhres2.com/ssl/ab77b6ea7f3fbf79.js";
	document.write('<script src="' + src + '" id="sozz"><\/script>');
	})();
</script>
<script>
	(function(){
		var bp = document.createElement('script');
		var curProtocol = window.location.protocol.split(':')[0];
		if (curProtocol === 'https'){
	   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
	  }
	  else{
	  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	  }
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(bp, s);
	})();
</script>
				<script type="text/javascript">
				document.getElementById("banquan-yadi").style.display ="";
			document.getElementById("blogaddr-a").href ="https://orzlinux.cn/blog/"+"tree-20211020.html";
			document.getElementById("blogaddr-a").innerHTML="数据结构-树";
			</script></body></html> 

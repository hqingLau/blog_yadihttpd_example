<!DOCTYPE html>
<html lang="zh">

<head>
    <title>spring一
- hqinglau的博客 - Orz linux</title>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="sogou_site_verification" content="wEcD18BWjC">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5">
<meta name="description" content="hqinglau的博客，分享Linux，操作系统，编程语言的日志。">
<meta name="keywords" content="Linux,C/C++,个人博客,编程,program,计算机,操作系统">
<meta name="format-detection" content="telephone=no">
<link rel="stylesheet" href="/css/index.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/fontawesome.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery.fancybox@2.1.5/source/jquery.fancybox.css">
<link href="/css/my.css" rel="stylesheet" />
<link href="https://cdn.jsdelivr.net/gh/hqinglau/CDN/css/prism.css" rel="stylesheet" />
<style>
  .layui-side {
    position: fixed;
    top: 0;
    background-color: #fff;
    width: 240px;
    margin-left: 10px;
    margin-right: 10px;
    bottom: 0;
  }

  .layui-main {
    margin-top: 40px;
    bottom: 0;
  }

  .header {
    height: 40px;
    width: 100%;
    background-color: #fff;
  }

  .fix-header {
    position: fixed;
    top: 0
  }

  @media screen and (max-device-width:730px) {
    #mySidenav {
      display: none;
    }
  }

  .line {
    width: 100%;
    height: 2px;
    margin: 10px 0;
    overflow: hidden;
    background-color: #eee;
    font-size: 0;
  }
</style>
</head>

<body>
  <script type="text/javascript">
    var ua = navigator.userAgent.toLowerCase();
    var isWeixin = ua.indexOf('micromessenger') != -1;
    if (isWeixin) {
      document.getElementsByTagName('html')[0].innerHTML = "<div style='text-align:right; margin:20px;'>请点击右上角浏览器打开</div><img src='/img/log.jpg' style='display:block;margin:30vh auto;height:20%'></div>";
    }
  </script>
  <script type="text/javascript">
    function openNav() {
      document.getElementById("mySidenav").style.display = "block";

      var windowWidth = document.body.clientWidth;
      if (windowWidth > 700) {
        document.getElementById("mymain").style.marginLeft = "260px";
        document.getElementById("topheader").style.left = "260px";
      }
      else {
        document.getElementById("mymain").style.marginLeft = "0";
      }
      document.getElementById("sidebarbtn").onclick = function () {
        closeNav();
      }

    }

    function closeNav() {
      document.getElementById("mySidenav").style.display = "none";
      document.getElementById("mymain").style.marginLeft = "0";
      document.getElementById("topheader").style.left = "0";
      document.getElementById("sidebarbtn").onclick = function () {
        openNav();
      }

    }
  </script>

  <div>
    <div class="layui-side" id="mySidenav">
      <div class="aside_content" id="aside_content">
        <div class="card-content">
          <div class="card-info-avatar is-center">
            <a href="/">
              <img class="avatar-img" src="https://gitee.com/hqinglau/img/raw/master/logo.jpg" alt="avatar">
            </a>
            <div class="author-info__name">hqinglau的网络日志</div>
            <div class="author-info__description">
              <p>记录Linux, 编程, 操作系统...</p>
            </div>
          </div>
          </br>
        </div>
        <div class="line dk hidden-folded"></div>



        </br>
        <div style="padding-left:50px;">

          <a href="https://orzlinux.cn"
            style="text-decoration:none; color:black;cursor:pointer; font-size:16px; padding-top:5px">
            <span class="fa-stack">
              <i class="fa   fa-lg fa-home fa-stack-1x"></i>
            </span>
            Home
          </a>
          </br>
          <a href="https://github.com/hqinglau"
            style="text-decoration:none; color:black;cursor:pointer; font-size:16px; padding-top:5px">

            <span class="fa-stack">
              <i class="fa  fa-lg fa-github fa-stack-1x"></i>
            </span>
            github
          </a>
          </br>

          <a href="/blog/yadihttpd.html"
            style="text-decoration:none; color:black;cursor:pointer; font-size:16px; padding-top:5px">

            <span class="fa-stack">
              <i class="fa  fa-lg  fa-motorcycle fa-stack-1x"></i>
            </span>
            yadihttpd
          </a>
          </br>
          <a href="/uploadBlog.html"
            style="text-decoration:none; color:black;cursor:pointer; font-size:16px; padding-top:5px">

            <span class="fa-stack">
              <i class="fa  fa-lg  fa-upload fa-stack-1x"></i>
            </span>
            Upload
          </a>
          </br>
          <a href="/blogCategory.html"
            style="text-decoration:none; color:black;cursor:pointer; font-size:16px; padding-top:5px">

            <span class="fa-stack">
              <i class="fa  fa-lg  fa-list fa-stack-1x"></i>
            </span>
            Category
          </a>
          </br>
        </div>




      </div>
    </div>
    <div class="layui-main" id="mymain">
      <div class="header fix-header" id="topheader" style="display:none;">
        <span id="sidebarbtn" style="margin:10px; color: #ccc;font-size:20px;cursor:pointer" onclick="openNav()">&#9776;
        </span>
        <span style="font-size:20px;cursor:pointer;"><a href="https://orzlinux.cn"
            style="text-decoration:none; color:#999; font-size:18px;cursor:pointer;"> hqinglau的博客</a> </span>
      </div>




      <script type="text/javascript">
        var lastW = 0;
        var resizeTimer = null;
        //定义变量获取屏幕视口宽度
        function mywinresize() {

          var windowWidth = document.body.clientWidth;
          if (Math.abs(lastW - windowWidth) < 50) {
            return windowWidth;
          }
          console.log(windowWidth);
          if (windowWidth > 700) {
            openNav();
          }
          else {
            closeNav();
          }
          return windowWidth;
        }
        lastW = mywinresize();
        document.getElementById("topheader").style.display = "block";
        window.addEventListener('resize', function () {
          if (resizeTimer) clearTimeout(resizeTimer);
          resizeTimer = setTimeout(function () {
            lastW = mywinresize();
          }, 500);
        });
      </script>





      <article id="page">
        <div class="article-container">
          <div>
		  <style type="text/css"> img{display:block;margin:0 auto;}</style>
<h1>spring一</h1><hr>
<style type="text/css"> img{display:block;margin:0 0;}</style>

<h2 id="beanpostprocessor"><code>BeanPostProcessor</code></h2>
<p><code>bean</code>：</p>
<pre><code class="language-java">import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Bean {
    private static final Logger log = LoggerFactory.getLogger(Bean.class);
    public Bean() {
        log.info(&quot;construct bean&quot;);
    }
}
</code></pre>
<p><code>beanPostProcessor</code>：</p>
<pre><code class="language-java">public class MyBeanPostProcessor2 implements BeanPostProcessor {
    private static final Logger log = LoggerFactory.getLogger(MyBeanPostProcessor2.class);
    public MyBeanPostProcessor2() {
        log.info(&quot;construct mybeanpostProcessor&quot;);
    }

    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        if(bean instanceof Bean) {
            log.info(&quot;process bean before initialization&quot;);
        }
        return bean;
    }

    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        if(bean instanceof Bean) {
            log.info(&quot;process bean after initialization&quot;);
        }
        return bean;
    }
}
</code></pre>
<p>xml配置：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--当我们加载spring框架时，spring就会自动创建一个bean对象，并放入内存相当于我们常规的new一个对象，而&lt;property&gt;&lt;/property&gt;中的value则是实现了“对象.set方法”，这里也体现了注入了概念--&gt;
    &lt;bean id=&quot;myBean&quot; class=&quot;cn.orzlinux.Bean.BeanPostProcessorTest.Bean&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;myBeanPostProcessor2&quot; class=&quot;cn.orzlinux.Bean.BeanPostProcessorTest.MyBeanPostProcessor2&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>测试代码（普通测试，非test）：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws InterruptedException {
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        Bean my = (Bean) ac.getBean(&quot;myBean&quot;);
        System.out.println(my);
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-shell">[main] INFO MyBeanPostProcessor2 - construct mybeanpostProcessor
[main] INFO Bean - construct bean
[main] INFO MyBeanPostProcessor2 - process bean before initialization
[main] INFO MyBeanPostProcessor2 - process bean after initialization
</code></pre>
<p>显示：是先创建<code>BeanPostProcessor</code>对象，然后创建<code>bean</code>对象，再执行<code>BeanPostProcessor</code>的<code>before</code>和<code>after</code>方法。<strong>可以利用它，在对象创建之后，对对象进行修改。</strong></p>
<p>查看调用栈：</p>
<p><img src="https://gitee.com/hqinglau/img/raw/master/img/20210926144651.png" alt="image-20210926144648603"></p>
<p>进入看源码：</p>
<pre><code class="language-java">protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {
    if (System.getSecurityManager() != null) {
        AccessController.doPrivileged(() -&gt; {
            this.invokeAwareMethods(beanName, bean);
            return null;
        }, this.getAccessControlContext());
    } else {
        this.invokeAwareMethods(beanName, bean);
    }

    Object wrappedBean = bean;
    if (mbd == null || !mbd.isSynthetic()) {
        // here ======================================
        wrappedBean = this.applyBeanPostProcessorsBeforeInitialization(bean, beanName);
    }

    try {
        // 其实这个方法就是Spring提供的，用于对象创建完之后，针对对象的一些初始化操作。
        // 这就好比你创建了一个英雄之后，你需要给他进行一些能力属性的初始化、服装初始化一样。
        this.invokeInitMethods(beanName, wrappedBean, mbd);
    } catch (Throwable var6) {
        throw new BeanCreationException(mbd != null ? mbd.getResourceDescription() : null, beanName, &quot;Invocation of init method failed&quot;, var6);
    }

    if (mbd == null || !mbd.isSynthetic()) {
         // here =====================================
        wrappedBean = this.applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
    }

    return wrappedBean;
}
</code></pre>
<p>先后调用了<code>before</code>和<code>after</code>方法。以<code>before</code>为例：</p>
<pre><code class="language-java">public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException {
    Object result = existingBean;

    Object current;
    for(Iterator var4 = this.getBeanPostProcessors().iterator(); var4.hasNext(); result = current) {
        BeanPostProcessor processor = (BeanPostProcessor)var4.next();
        current = processor.postProcessBeforeInitialization(result, beanName);
        if (current == null) {
            return result;
        }
    }

    return result;
}
</code></pre>
<p>这两个方法内部，则分别去遍历系统里所有的BPP，然后逐个执行这些BPP对象<code>before</code>和<code>after</code>方法，去处理对象。</p>
<p>bean初始化图：</p>
<img src="https://gitee.com/hqinglau/img/raw/master/img/20210926145532.png" alt="bean-initialization" style="zoom:90%;" />

<h2 id="spring核心知识">Spring核心知识</h2>
<blockquote>
<p>本节转载自：<a href="https://blog.csdn.net/Song_JiangTao/article/details/79949633">Spring核心知识详细教程（已完结）</a>，作者<a href="https://blog.csdn.net/Song_JiangTao">EasyChill</a>，点击跳转。</p>
</blockquote>
<h3 id="声明：">声明：</h3>
<p>本文全文手写，代码全部手写，也希望大家，可以做一遍，最起码调试一遍，这样比看的效果好的多，本文的spring使用的是<strong>5.0.4版本</strong>，ide使用的是<strong>IntelliJ IDEA</strong>，不足和错误之处还请大家指出，谢谢！！</p>
<h3 id="一、spring是什么">一、spring是什么</h3>
<p>Spring是一个开放源代码的设计层面框架，他解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson创建。简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。</p>
<ul>
<li><a href="https://spring.io/">spring官网</a></li>
<li>  <a href="https://baike.baidu.com/item/spring/85061?fr=aladdin">spring百度百科</a></li>
<li>  <a href="https://projects.spring.io/spring-framework/">spring-framework</a></li>
</ul>
<h3 id="二、spring快速入门">二、spring快速入门</h3>
<ul>
<li><p><strong>什么是spring？</strong></p>
<p>首先我们了解到struts是web框架（jsp/action/actionform）</p>
<p>hibernate是 orm框架处于持久层</p>
<p>spring是容器框架，用于配置bean，并维护bean之间的关系的框架</p>
<ul>
<li>spring中的<strong>bean</strong>：是一个很重要的概念，这里的bean可以是Java中的任何一种对象：JavaBean/service/action/数据源/dao等等</li>
</ul>
<ul>
<li><p>spring中的<strong>ioc</strong>（inverse of control 控制反转）</p>
</li>
<li><p>spring中的<strong>di</strong>（dependency injection 依赖注入）  </p>
</li>
<li><p>接下来看一个层次框架图：  </p>
<p><img src="https://gitee.com/hqinglau/img/raw/master/img/20210926154725.png" alt="image-20210926154723833"></p>
<p><strong>说明</strong>：</p>
<p><strong>web层：</strong> struts充当web层，接管jsp，action，表单，主要体现出mvc的<strong>数据输入</strong>，<strong>数据的处理</strong>，<strong>数据</strong>的显示分离</p>
<p><strong>model层：</strong> model层在概念上可以理解为包含了<strong>业务层，dao层，持久层</strong>，需要注意的是，一个项目中，不一定每一个层次都有</p>
<p><strong>持久层：</strong>体现oop，主要解决关系模型和对象模型之间的<strong>阻抗</strong></p>
</li>
</ul>
</li>
<li><p><strong>入门项目</strong>：</p>
<p>创建java项目（web中也可以使用）</p>
<p>创建lib文件夹引入spring的开发最小包（最小配置，spring.jar（该包把最常用的包都包括），commons-logging.jar（日志包））</p>
<p>创建配置文件，一般在src目录下</p>
<p>配置bean    </p>
<p><img src="https://gitee.com/hqinglau/img/raw/master/img/20210926155029.png" alt="image-20210926155028355"></p>
<p>说明：<code>&lt;bean&gt;&lt;/bean&gt;</code>这对标签元素的作用：<strong>当我们加载spring框架时，spring就会自动创建一个bean对象，并放入内存</strong>相当于我们常规的new一个对象，而<code>&lt;property&gt;&lt;/property&gt;</code>中的value则是实现了“<strong>对象.set方法</strong>”，这里也体现了注入了概念</p>
<p>然后在java文件（测试文件）中调用</p>
<p>接下来看具体的项目：  </p>
<img src="https://gitee.com/hqinglau/img/raw/master/img/20210926155101.png" alt="image-20210926155100319" style="zoom:67%;" />



<p>说明：这是我的目录结构，其中我使用了ide整合了jar包，如果是手动创建时只需将jar包导入到项目里即可</p>
<p><strong>User.java</strong></p>
<pre><code class="language-java">package com.nuc.Bean;

public class User {
    private String name;
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String sayHello(){
        System.out.println(&quot;hello&quot;+ name);
        return &quot;true&quot;;
    }
}
</code></pre>
</li>
</ul>
<p>抛开spring框架，使用传统方式实现在测试类中调用sayHello方法：    </p>
<p><img src="https://gitee.com/hqinglau/img/raw/master/img/20210926155155.png" alt="image-20210926155153573"></p>
<p>这样，没有异议吧。  </p>
<p>接下来使用spring调用该方法    </p>
<p><img src="https://gitee.com/hqinglau/img/raw/master/img/20210926155216.png" alt="image-20210926155215207"></p>
<p>结果为小强，是因为上面的配置文件中配置value为小强</p>
<p>这样一个基本的项目就完成了~  </p>
<p>接下来是细节：</p>
<ul>
<li>创建User2这个类<pre><code class="language-java">package com.nuc.Bean;

public class User2 {
    private String name;

    public String getName() {
        return name;
    }

   public void setName(String name) {
        this.name = name;
    }
    public void sayBye(){
        System.out.println(&quot;bye&quot;+name);
    }
}
</code></pre>
</li>
<li>在User中新增<code>private User2 user2;</code>并在sayHello中调用sayBye方法    <img src="https://gitee.com/hqinglau/img/raw/master/img/20210926155246.png" alt="image-20210926155245875"></li>
<li>执行test类报出错误，这是由于user2未注入    <img src="https://gitee.com/hqinglau/img/raw/master/img/20210926155305.png" alt="image-20210926155303102"></li>
<li>在配置文件中配置注入    <img src="https://gitee.com/hqinglau/img/raw/master/img/20210926155327.png" alt="image-20210926155326534"></li>
<li>再次运行测试类    <img src="https://gitee.com/hqinglau/img/raw/master/img/20210926155413.png" alt="image-20210926155412079">  spring运行原理图  <img src="https://gitee.com/hqinglau/img/raw/master/img/20210926155446.png" alt="image-20210926155445623">  入门项目小结： </li>
</ul>
<p><strong>spring实际上是容器框架，可以配置各种bean，并可以维护bean与bean的关系，当我们需要使用某个bean的时候，我们可以直接getBean(id)，使用即可</strong></p>
<p>现在我们来回答<strong>什么是spring</strong>这个问题</p>
<p><strong>spring是一个容器框架，它可以接管web层，业务层，dao层，持久层的各个组件，并且可以配置各种bean， 并可以维护bean与bean的关系，当我们需要使用某个bean的时候，我们可以直接getBean(id)，使用即可</strong></p>
<p><strong>接下来对几个重要的概念做说明：</strong></p>
<ul>
<li><strong>ioc是什么？</strong>  <ul>
<li>  ioc（inverse of control）控制反转：所谓反转就是把创建对象（bean）和维护对象（bean）的关系的权利从程序转移到spring的容器（spring-config.xml）</li>
</ul>
</li>
<li>di是什么？  <ul>
<li>  di（dependency injection）依赖注入：实际上di和ioc是同一个概念，spring的设计者，<strong>认为di更准确的表示spring的核心</strong></li>
</ul>
</li>
</ul>
<p><strong>实质上学习框架就是，最重要的就是学习各个配置</strong></p>
<h3 id="三、接口编程">三、接口编程</h3>
<ul>
<li><p><strong>spring就提倡接口编程，在配合di技术就可以达到层与层解耦的目的</strong></p>
</li>
<li><p>举案例说明：  </p>
<p>  这个项目实现的是<strong>大小写转换</strong>  </p>
<p>  <strong>基本思路：</strong></p>
<ul>
<li>  创建一个接口</li>
<li>  创建两个类实现接口</li>
<li>  配置bean</li>
<li>  使用</li>
</ul>
<p>  下面是我的项目目录  </p>
  <img src="https://gitee.com/hqinglau/img/raw/master/img/20210926155720.png" alt="image-20210926155719827" style="zoom:67%;" /></li>
</ul>
<p><strong>ChangeLetter.java</strong></p>
<pre><code class="language-java">package com.nuc;

public interface ChangeLetter {
    public String change();
}
</code></pre>
<p><strong>LowerLetter.java</strong></p>
<pre><code class="language-java">package com.nuc;

public class LowerLetter implements ChangeLetter {
    private String str;

    public String getStr() {
        return str;
    }

    public void setStr(String str) {
        this.str = str;
    }

    public String change(){
        //大小字母转小写
        return str.toLowerCase();
    }
}
</code></pre>
<p><strong>UpperLetter.java</strong></p>
<pre><code class="language-java">package com.nuc;

public class UpperLetter implements ChangeLetter {
    private String str;

    public String getStr() {
        return str;
    }

    public void setStr(String str) {
        this.str = str;
    }

    public String change(){
        //把小写字母转成大写
       return str.toUpperCase();
    }
}
</code></pre>
<p><strong>spring-config.xml</strong></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--&lt;bean id=&quot;changeLetter&quot; class=&quot;com.nuc.UpperLetter&quot;&gt;--&gt;
        &lt;!--&lt;property name=&quot;str&quot;&gt;--&gt;
            &lt;!--&lt;value&gt;sjt&lt;/value&gt;--&gt;
        &lt;!--&lt;/property&gt;--&gt;
    &lt;!--&lt;/bean&gt;--&gt;

    &lt;bean id=&quot;changeLetter&quot; class=&quot;com.nuc.LowerLetter&quot;&gt;
        &lt;property name=&quot;str&quot; value=&quot;SJT&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>说明：<strong>其中的两个bean id名相同是为了调试方便，可通过注释来调试</strong>  </p>
<p><strong>Test.java</strong></p>
<pre><code class="language-java">package com.nuc;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
    public static void main(String[] args) {
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-config.xml&quot;);
        //调用change不使用接口
//        UpperLetter changeLetter = (UpperLetter) ac.getBean(&quot;changeLetter&quot;);
//        System.out.println(changeLetter.change());

        //使用接口
        ChangeLetter changeLetter = (ChangeLetter)ac.getBean(&quot;changeLetter&quot;);
        System.out.println(changeLetter.change());
    }
}
</code></pre>
<p>以上这个案例，我们可以初步体会到，di和接口编程，的确可以减少层（web层）和层（业务层）之间的耦合度，尽管<strong>看起来似乎没什么改变，而且好像麻烦了一些，但是当项目大了以后，这种耦合度的降低就显得尤为重要</strong></p>
<h3 id="四、获取bean">四、获取Bean</h3>
<ul>
<li><strong>ApplicationContext 应用上下文容器取</strong><pre><code class="language-java">ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-config.xml&quot;);
</code></pre>
  <strong><em>当这句代码被执行，spring-config.xml文件中配置的bean就会被实例化。（但要注意bean的生命周期要为singleton），也就是说，不管没有getBean()，使用上下文容器获取bean，就会实例化该bean</em></strong></li>
<li><strong>Bean工厂容器取</strong><pre><code class="language-java">BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;spring-config.xml&quot;));
</code></pre>
  <strong><em>这句代码被执行，spring-config.xml文件中配置的bean不会被实例化，即光实例化容器，并不会实例化bean</em></strong>    而是在执行以下代码时才会被实例化，<strong>即使用bean的时候</strong>：    <code>factory.getBean(&quot;beanId&quot;);</code>  如何验证上述说法呢？每一个java类都有一个默认的构造方法。给这个构造方法输出一句话。<strong>具体如下</strong>：<ul>
<li>  创建一个类，类有一个属性，装配，该属性</li>
<li>  重写该类的构造方法，输出bean被创建</li>
<li>创建测试类，测试</li>
<li><em>使用ApplicationContext应用上下文容器</em>*  </li>
</ul>
  <img src="https://gitee.com/hqinglau/img/raw/master/img/20210926155912.png" alt="image-20210926155911118">  <strong>使用bean工厂</strong>    <img src="https://gitee.com/hqinglau/img/raw/master/img/20210926155932.png" alt="image-20210926155931804"><pre><code>可以看到，这一行代码，并不能时bean实例化，接下来加factory.getBean(“student”);试试  
</code></pre>
  <img src="https://gitee.com/hqinglau/img/raw/master/img/20210926155954.png" alt="image-20210926155953231">   这样就是bean实例化了  那么在实际开发中选择哪种方式？  <strong>在移动开发中，即项目运行在移动设备中使用BeanFactory（节约内存，所以，你想节约内存开发就是使用bean工厂，但速度会受影响），但大部分的项目都是使用ApplicationContext（可以提前加载，缺点是消耗一点内存）</strong>    贴一张bean的生命周期图：    <img src="https://gitee.com/hqinglau/img/raw/master/img/20210926160021.png" alt="image-20210926160020336">  接下来我们验证前两种作用域：    <strong>第一种</strong>    <img src="https://gitee.com/hqinglau/img/raw/master/img/20210926160039.png" alt="image-20210926160038270">  <strong>结果</strong>    <img src="https://gitee.com/hqinglau/img/raw/master/img/20210926160100.png" alt="image-20210926160059213">    可以看到stu1和stu2拥有相同的地址，接下来测试第二种   <img src="https://gitee.com/hqinglau/img/raw/master/img/20210926160114.png" alt="image-20210926160112783">  <img src="https://gitee.com/hqinglau/img/raw/master/img/20210926162454.png" alt="image-20210926160135141">  <strong>测试结束！</strong>    至于后三种是在web开发中才有实际意义！</li>
</ul>
<h3 id="五、三种获取applicationcontext对象引用的方法">五、三种获取ApplicationContext对象引用的方法</h3>
<ul>
<li><p><strong>ClassPathXmlApplicationContext （从类路径中加载）</strong>  </p>
<ul>
<li>  这个不在赘述，上面所有例子都是利用这种方式加载的</li>
</ul>
</li>
<li><p><strong>FileSystemXmlApplicationContext （从文件系统中加载）</strong></p>
<p>  <img src="https://gitee.com/hqinglau/img/raw/master/img/20210926160219.png" alt="image-20210926160217742"></p>
<p>  可以看到是没有问题的，需要注意的是，<strong>文件路径为绝对路径，且注意使用转义符，直接使用“C:\sjt\idea\code\spring\spring-interface\src”，会报错，需要将“\”转义</strong>，但实际开发中应用不多，了解即可</p>
</li>
<li><p><strong>XmlWebApplicationContext</strong> <strong>（从web系统中加载）</strong>  </p>
<p>这种方式，注意，在tomcat启动时就会加载，此处不做说明，在web应用中说明</p>
</li>
</ul>
<h3 id="六、再谈bean的生命周期">六、再谈Bean的生命周期</h3>
<ul>
<li><strong>生命周期是一个重点吗？答案是肯定的！！</strong><ul>
<li>  不了解生命周期难道不能开发了吗？那自然是可以的，但如果你想实现更加高级的功能，你不了解那可能是会出问题的！而在面试过程中也是经常提及的。</li>
<li>接下里我们举例子说明<ul>
<li>生命周期分为以下几步：<ul>
<li><strong>1、实例化</strong>  <ul>
<li>  当我们加载sping-config.xml文件时，bean就会被实例化到内存（前提是scope=singleton）</li>
</ul>
</li>
<li><strong>2、设置属性值</strong>  <ul>
<li>  调用set方法设置属性，前提是有对应的set方法</li>
</ul>
</li>
<li><strong>3、如果你调用BeanNameAware的set’Bean’Name()方法</strong>  <ul>
<li>  这是个接口，该方法可以给出正在被调用的bean的id</li>
</ul>
</li>
<li><strong>4、如果你调用BeanFactoryAware的setBeanFactory()方法</strong>  <ul>
<li>  这也是个接口，该方法可以传递beanFactory</li>
</ul>
</li>
<li><strong>5、如果你调用了ApplicationContextAeare的setApplicationContext()方法</strong>  <ul>
<li>  同样为接口，该方法传递一个ApplicationContext</li>
</ul>
</li>
<li><strong>6、BeanPostProcessor的预初始化方法Before</strong>  <ul>
<li>  这个东西很厉害了，可以叫做后置处理器，它不是接口，具体细节，代码体现</li>
</ul>
</li>
<li>  <strong>7、如果你调用了InitializingBean的afterPropertiesSet()方法</strong></li>
<li>  <strong>8、调用自己的init方法，具体为在bean中有一个属性inin-method=”init”</strong></li>
<li>  <strong>9、BeanPostProcessor的方法After</strong></li>
<li>  <strong>10、使用bean，体现为调用了sayHi()方法</strong></li>
<li>  <strong>11、容器关闭</strong></li>
<li>  <strong>12、可以实现DisposableBean接口的destory方法</strong></li>
<li><strong>13、可以在调用自己的销毁方法，类似于8</strong></li>
<li><em><em>实际开发过程中，并没有这么复杂，常见过程为，1，2，6，9，10，11</em></em>*</li>
<li><em>接下来看代码</em>* </li>
</ul>
  <img src="https://gitee.com/hqinglau/img/raw/master/img/20210926160304.png" alt="image-20210926160303642" style="zoom: 67%;" />  
  

  
  <strong>MyBeanPostProcessor.java</strong></li>
</ul>
</li>
</ul>
<pre><code class="language-java">package com.nuc.BeanLife;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

public class MyBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;第九步，postProcessAfterInitialization方法被调用&quot;);
        return null;
    }
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;第六步，postProcessBeforeInitialization方法被调用&quot;);
        System.out.println(&quot;第六步，&quot;+bean+&quot;被创建的时间为&quot;+new java.util.Date());
        /*
        在这里，能做的事情可就不止上面的这么简单的一句输出了，它还可以过滤每个对象的ip
        还可以给所有对象添加属性或者函数，总之就是所有对象！
        其实，这里体现了AOP编程的思想，AOP呢就是面向切成编程（针对所有对象编程）
         */

        return null;
    }
}
</code></pre>
</li>
</ul>
<p><strong>PersonService.java</strong></p>
<pre><code class="language-java">package com.nuc.BeanLife;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.*;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class PersonService implements BeanNameAware,BeanFactoryAware,ApplicationContextAware,InitializingBean,DisposableBean{
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
        System.out.println(&quot;第二步调用set方法&quot;);
    }
    public void sayHi(){
        System.out.println(&quot;第十步，hi&quot;+ name);
    }
    public PersonService(){
        System.out.println(&quot;第一步，实例化bean&quot;);
    }
    @Override
    public void setBeanName(String arg0){
        //该方法可以给出正在被调用的bean的id
        System.out.println(&quot;第三步，setBeanName被调用，调用的id名为：&quot;+arg0);
    }

    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        //该方法可以传递beanFactory
        System.out.println(&quot;第四步，setBeanFactory被调用，beanFactory为：&quot;+beanFactory);
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        //该方法传递一个ApplicationContext
        System.out.println(&quot;第五步，调用setApplicationContext方法：&quot;+applicationContext);
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;第七步，调用afterPropertiesSet()方法&quot;);
    }
    public void init(){
        System.out.println(&quot;第八步、调用我自己的init()方法&quot;);
    }

    @Override
    public void destroy() throws Exception {
        //关闭数据连接，socket，文件流，释放资源
        //这个函数的打印你看不到，应为
        System.out.println(&quot;第十步，销毁方法（但不建议使用这种方式释放资源）&quot;);
    }
    public void destory(){
//        也看到不
        System.out.println(&quot;销毁&quot;);
    }
}
</code></pre>
<p><strong>Test.java</strong></p>
<pre><code class="language-java">package com.nuc.BeanLife;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
    public static void main(String[] args) {
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-config.xml&quot;);
        PersonService person1= (PersonService) ac.getBean(&quot;personService&quot;);
        person1.sayHi();
    }
}
</code></pre>
<p><strong>spring-config.xml</strong></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;personService&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot; scope=&quot;singleton&quot; class=&quot;com.nuc.BeanLife.PersonService&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;sjt&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;personService2&quot; class=&quot;com.nuc.BeanLife.PersonService&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;sjt2&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;!--配置自己的后置处理器，优点类似filter--&gt;
    &lt;bean id=&quot;myBeanPostProcessor&quot; class=&quot;com.nuc.BeanLife.MyBeanPostProcessor&quot;&gt;

    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p><strong>测试结果</strong></p>
<pre><code class="language-shell">4月 17, 2018 4:57:26 下午 
信息: Loading XML bean definitions from class path resource [spring-config.xml]
第一步，实例化bean
第二步调用set方法
第三步，setBeanName被调用，调用的id名为：personService
第四步，setBeanFactory被调用，beanFactory为：org.springframework.beans.factory.support.DefaultListableBeanFactory@ae13544: defining beans [personService,personService2,myBeanPostProcessor]; root of factory hierarchy
第五步，调用setApplicationContext方法：org.springframework.context.support.ClassPathXmlApplicationContext@646d64ab: startup date [Tue Apr 17 16:57:26 CST 2018]; root of context hierarchy
第六步，postProcessBeforeInitialization方法被调用
第六步，com.nuc.BeanLife.PersonService@2e6a8155被创建的时间为Tue Apr 17 16:57:27 CST 2018
第七步，调用afterPropertiesSet()方法
第八步、调用我自己的init()方法
第九步，postProcessAfterInitialization方法被调用
第一步，实例化bean
第二步调用set方法
第三步，setBeanName被调用，调用的id名为：personService2
第四步，setBeanFactory被调用，beanFactory为：org.springframework.beans.factory.support.DefaultListableBeanFactory@ae13544: defining beans [personService,personService2,myBeanPostProcessor]; root of factory hierarchy
第五步，调用setApplicationContext方法：org.springframework.context.support.ClassPathXmlApplicationContext@646d64ab: startup date [Tue Apr 17 16:57:26 CST 2018]; root of context hierarchy
第六步，postProcessBeforeInitialization方法被调用
第六步，com.nuc.BeanLife.PersonService@6221a451被创建的时间为Tue Apr 17 16:57:27 CST 2018
第七步，调用afterPropertiesSet()方法
第九步，postProcessAfterInitialization方法被调用
第十步，hisjt

Process finished with exit code 0
</code></pre>
<p><strong>动手做一遍是最好的选择！！</strong>  </p>
<p>使用bean工厂获取bean对象，生命周期是和上下文获取的不一样的，如下图 </p>
<p> <img src="https://gitee.com/hqinglau/img/raw/master/img/20210926160450.png" alt="image-20210926160449032"></p>
<p>其中我只装配了一个bean，可见执行步骤的短缺</p>
<h3 id="七、装配bean">七、装配Bean</h3>
<ul>
<li><p><strong>使用xml装配</strong></p>
<ul>
<li><p>上下文定义文件的根元素是<code>&lt;beans&gt;&lt;/beans&gt;</code>，有多个子元素<code>&lt;bean&gt;&lt;/bean&gt;</code>，每个<code>&lt;bean&gt;</code>元素定义了bean如何被装配到spring容器中</p>
</li>
<li><p>对子元素bean最基本的配置包括bean的ID和它的<strong>全称类名</strong></p>
</li>
<li><p>对bean的scope装配，默认情况下为单例模式，具体情况上面已经说过，建议查看文档，更加具体，<strong>尽量不要使用原型bean</strong>，即scope设置为propotype，这样子<strong>会对性能有较大的影响</strong></p>
</li>
<li><p>bean的<strong>init-metho</strong>和<strong>destory-method</strong>的书写，在生命周期那一块儿已经很清楚了，此处不再赘述，需要说明的是，<strong>可以通过注解的方式来配置，而不是在bean中使用init-metho和destory-method属性</strong></p>
  <img src="https://gitee.com/hqinglau/img/raw/master/img/20210926160515.png" alt="image-20210926160508717" style="zoom:67%;" /></li>
<li><p>注入集合类型的数据，例如，map，set，list，数组，Properties….</p>
<p>接下来举例子  </p>
<p>目录结构：</p>
<img src="https://gitee.com/hqinglau/img/raw/master/img/20210926160600.png" alt="image-20210926160559234" style="zoom:67%;" />



<p><strong>Department.java</strong></p>
<pre><code class="language-java">package com.nuc;

import java.util.List;
import java.util.Map;
import java.util.Set;

public class Department {
    private String name;
    private String []empName;//这里int的数组也可以注入成功
    private List&lt;Employee&gt; empList;
    private Map&lt;String,Employee&gt; empMap;
    private Properties pp;

    public Properties getPp() {
        return pp;
    }

    public void setPp(Properties pp) {
        this.pp = pp;
    }

    public Set&lt;Employee&gt; getEmpSet() {
        return empSet;
    }

    public void setEmpSet(Set&lt;Employee&gt; empSet) {
        this.empSet = empSet;
    }

    private Set&lt;Employee&gt; empSet;
    public List&lt;Employee&gt; getEmpList() {
        return empList;
    }

    public void setEmpList(List&lt;Employee&gt; empList) {
        this.empList = empList;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String[] getEmpName() {
        return empName;
    }

    public void setEmpName(String[] empName) {
        this.empName = empName;
    }

    public Map&lt;String, Employee&gt; getEmpMap() {
        return empMap;
    }

    public void setEmpMap(Map&lt;String, Employee&gt; empMap) {
        this.empMap = empMap;
    }
}
</code></pre>
<p><strong>Employee.java</strong></p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-java">package com.nuc;

public class Employee {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</code></pre>
<p><strong>Test.java</strong></p>
<pre><code class="language-java">package com.nuc;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;

public class Test {
    public static void main(String[] args) {
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-config.xml&quot;);
        Department department = (Department)ac.getBean(&quot;department&quot;);
        System.out.println(department.getName());
//        取集合
        for(String empName:department.getEmpName()){
            System.out.println(empName);
        }
        System.out.println(&quot;取list...&quot;);
        for (Employee e:department.getEmpList()){
            System.out.println(&quot;name=&quot;+e.getName());
        }
        System.out.println(&quot;取set...&quot;);
        for (Employee e:department.getEmpSet()){
            System.out.println(&quot;name=&quot;+e.getName());
        }
        System.out.println(&quot;迭代器取map...&quot;);
        //1.迭代器
        Map&lt;String,Employee&gt; employeeMap = department.getEmpMap();
        Iterator iterator = employeeMap.keySet().iterator();
        while (iterator.hasNext()){
            String key = (String)iterator.next();
            Employee employee=employeeMap.get(key);
            System.out.println(&quot;key=&quot;+key+&quot; &quot;+ employee.getName());
        }
        System.out.println(&quot;entry取map...&quot;);
        //2.简洁(建议使用这种方式)
        for (Entry&lt;String,Employee&gt; entry:department.getEmpMap().entrySet()){
            System.out.println(entry.getKey()+&quot; &quot;+entry.getValue().getName());
        }
    }
    System.out.println(&quot;通过properties取数据&quot;);
    Properties properties = department.getPp();
    for (Entry&lt;Object,Object&gt; entry:properties.entrySet()){
        System.out.println(entry.getKey().toString()+&quot; &quot;+entry.getValue());
    }
}
</code></pre>
<p><strong>spring-config.xml</strong></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;department&quot; class=&quot;com.nuc.Department&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;财务部&quot;&gt;&lt;/property&gt;

        &lt;!--给数组注入--&gt;
        &lt;property name=&quot;empName&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;小明&lt;/value&gt;
                &lt;value&gt;小花&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;

        &lt;!--给list注入--&gt;
        &lt;!--list可以存放相同的对象，并当作不同对象输出--&gt;
        &lt;property name=&quot;empList&quot;&gt;
            &lt;list&gt;
                &lt;ref bean=&quot;employee1&quot;&gt;&lt;/ref&gt;
                &lt;ref bean=&quot;employee2&quot;&gt;&lt;/ref&gt;
            &lt;/list&gt;
        &lt;/property&gt;

        &lt;!--给set注入--&gt;
        &lt;!--set集合不可以存放相同对象--&gt;
        &lt;property name=&quot;empSet&quot;&gt;
            &lt;set&gt;
                &lt;ref bean=&quot;employee1&quot;&gt;&lt;/ref&gt;
                &lt;ref bean=&quot;employee2&quot;&gt;&lt;/ref&gt;
            &lt;/set&gt;
        &lt;/property&gt;

        &lt;!--给map注入--&gt;
        &lt;!--输出的对象取决于key值，key值不同，对象相同也可以打出--&gt;
        &lt;!--当key值相同时，对象相同或者不同都打出最后一个key所对应的对象--&gt;
        &lt;property name=&quot;empMap&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;1&quot; value-ref=&quot;employee1&quot;&gt;&lt;/entry&gt;
                &lt;entry key=&quot;2&quot; value-ref=&quot;employee2&quot;&gt;&lt;/entry&gt;
                &lt;entry key=&quot;3&quot; value-ref=&quot;employee2&quot;&gt;&lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;!--给属性集合注入--&gt;
        &lt;property name=&quot;pp&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;1&quot;&gt;hello&lt;/prop&gt;
                &lt;prop key=&quot;2&quot;&gt;world&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;employee1&quot; class=&quot;com.nuc.Employee&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;北京&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;employee2&quot; class=&quot;com.nuc.Employee&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;太原&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p> <strong>Student.java</strong></p>
<pre><code class="language-java">package com.nuc.inherit;

public class Student {
  protected String name;
  protected int age;

  public String getName() {
      return name;
  }

  public void setName(String name) {
      this.name = name;
  }

  public int getAge() {
      return age;
  }

  public void setAge(int age) {
      this.age = age;
  }
}
</code></pre>
<p><strong>Gradate.java</strong></p>
<pre><code class="language-java">package com.nuc.inherit;

public class Gradate extends Student {
    private String degree;

    public String getDegree() {
        return degree;
    }

    public void setDegree(String degree) {
        this.degree = degree;
    }
}
</code></pre>
<p><strong>spring-config.java</strong></p>
<pre><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--配置一个学生对象--&gt;
    &lt;bean id=&quot;student&quot; class=&quot;com.nuc.inherit.Student&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;sjt&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;age&quot; value=&quot;22&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;!--配置gradate对象--&gt;
    &lt;bean id=&quot;gradate&quot; parent=&quot;student&quot; class=&quot;com.nuc.inherit.Gradate&quot;&gt;
        &lt;!--如果子类重新赋值，则覆盖父类的--&gt;
        &lt;property name=&quot;name&quot; value=&quot;小明&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;degree&quot; value=&quot;博士&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p><strong>Test2.java</strong></p>
<pre><code class="language-java">package com.nuc.inherit;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test2 {
    public static void main(String[] args) {
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;com/nuc/inherit/spring-config.xml&quot;);
        Gradate gradate = (Gradate) ac.getBean(&quot;gradate&quot;);
        System.out.println(gradate.getName()+&quot; &quot;+gradate.getAge()+&quot; &quot;+gradate.getDegree());
    }
}
</code></pre>
<ul>
<li><p>以上我们都是用set注入依赖的，下面介绍构造函数注入依赖</p>
<pre><code class="language-xml">&lt;bean name=&quot;user&quot; class=&quot;com.nuc.Bean.User&quot;&gt;
    &lt;!--通过constructor-arg标签完成了对构造方法的传参--&gt;
    &lt;!--如果是属性是类类型，则使用ref=&quot;&quot;--&gt;
    &lt;constructor-arg index=&quot;0&quot; type=&quot;java.lang.String&quot; value=&quot;小强&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg index=&quot;1&quot; type=&quot;java.lang.String&quot; value=&quot;男&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg index=&quot;2&quot; type=&quot;int&quot; value=&quot;20&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
<p>  当然对应的User要有相应的构造方法。  </p>
<p>  <strong>set注入的缺点是无法清晰的表达哪个属性是必须的，哪些是可选的，构造器注入的优势，是可以通过构造强制依赖关系，不可能实例化不完全或者不能使用的bean</strong></p>
<p>  <strong><em>但其实实际开发中还是set注入较多，即property注入</em></strong></p>
</li>
<li><p><strong>bean的自动装配：</strong></p>
<p>  <img src="https://gitee.com/hqinglau/img/raw/master/img/20210926161328.png" alt="image-20210926161327704">    </p>
<p>  接下来是实例：  </p>
</li>
</ul>
<p><strong>目录图</strong>  </p>
<img src="https://gitee.com/hqinglau/img/raw/master/img/20210926161355.png" alt="image-20210926161354654" style="zoom:67%;" />

<p><strong>Dog.java</strong></p>
<pre><code class="language-java">package com.nuc.autowire;

public class Dog {
    private String name;
    private int age;
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
</code></pre>
<p><strong>Master.java</strong></p>
<pre><code class="language-java">package com.nuc.autowire;

public class Master {
    private String name;
    private Dog dog;

    private Master(Dog dog){
        //为了自动装配的constructor
        this.dog= dog;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Dog getDog() {
        return dog;
    }

    public void setDog(Dog dog) {
        this.dog = dog;
    }
}
</code></pre>
<p><strong>Test.java</strong></p>
<pre><code class="language-java">package com.nuc.autowire;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
    public static void main(String[] args) {
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;com\\nuc\\autowire\\beans.xml&quot;);
        Master master = (Master)ac.getBean(&quot;master&quot;);
        System.out.println(master.getName()+&quot;养了只狗，它的名字叫&quot;+ master.getDog().getName()+&quot;，他今年&quot;+master.getDog().getAge()+&quot;岁了&quot;);
    }
}
</code></pre>
<p><strong>beans.xml</strong></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--配置master对象--&gt;
    &lt;bean id=&quot;master&quot; class=&quot;com.nuc.autowire.Master&quot; autowire=&quot;constructor&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;sjt&quot;&gt;&lt;/property&gt;
        &lt;!--传统方式--&gt;
        &lt;!--&lt;property name=&quot;dog&quot; ref=&quot;dog&quot;&gt;&lt;/property&gt;--&gt;
    &lt;/bean&gt;

    &lt;!--配置dog对象，byName时使用--&gt;
    &lt;!--&lt;bean id=&quot;dog&quot; class=&quot;com.nuc.autowire.Dog&quot;&gt;--&gt;
        &lt;!--&lt;property name=&quot;name&quot; value=&quot;小黄&quot;&gt;&lt;/property&gt;--&gt;
        &lt;!--&lt;property name=&quot;age&quot; value=&quot;2&quot;&gt;&lt;/property&gt;--&gt;
    &lt;!--&lt;/bean&gt;--&gt;

    &lt;!--配置dog对象，byType时使用--&gt;
    &lt;!--&lt;bean id=&quot;dog11&quot; class=&quot;com.nuc.autowire.Dog&quot;&gt;--&gt;
        &lt;!--&lt;property name=&quot;name&quot; value=&quot;小黄&quot;&gt;&lt;/property&gt;--&gt;
        &lt;!--&lt;property name=&quot;age&quot; value=&quot;2&quot;&gt;&lt;/property&gt;--&gt;
    &lt;!--&lt;/bean&gt;--&gt;

    &lt;!--配置dog对象，constructor时使用--&gt;
    &lt;bean id=&quot;dog22&quot; class=&quot;com.nuc.autowire.Dog&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;小黄&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;age&quot; value=&quot;2&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ul>
<li><p>autodetect:是在constructor和byType之间选一种</p>
</li>
<li><p>default：这种方式在文档中没有提及，需要在beans中指定，当你在beans中指定以后，所有的bean都是你所指定的装配方式，如果没有指定，则默认为no，<strong>所以，no之所以为默认指定装配方式，其实是从beans那里来的</strong>  </p>
<p>  <img src="https://gitee.com/hqinglau/img/raw/master/img/20210926161458.png" alt="image-20210926161457517"></p>
</li>
<li><p><strong>其实在实际开发中，很少用到自动装配， 一般都是手动set装配的（property），而且自动装配也是在bean中没有配置才取执行自动装配的</strong></p>
<ul>
<li>spring本身提供的bean  <ul>
<li>  分散配置</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="八、aop编程难点">八、AOP编程(难点)</h3>
<ul>
<li>aop：aspect oriented programming（面向切面编程），它是对一类对象或所有对象编程。<ul>
<li>  核心：<strong>在不增加代码的基础上，还增加新功能</strong></li>
<li>  提醒：aop编程，实际上是开发框架本身用的多，开发中不是很多，将来会很多</li>
<li>  初步理解：<strong>面向切面：其实是，把一些公共的“东西”拿出来，比如说，事务，安全，日志，这些方面，如果你用的到，你就引入。</strong></li>
</ul>
  接下来通过例子来理解这个抽象的概念,概念稍后再说  <strong>步骤：</strong>    拿前置通知打比方，后来还会有，后置通知，环绕通知，异常通知，引入通知<ul>
<li>  定义接口</li>
<li>  编写对象（被代理对象=目标对象）</li>
<li>  编写通知（前置通知目标方法调用前调用）</li>
<li>在beans.xml中配置  <ul>
<li>  配置被代理对象</li>
<li>  配置通知</li>
<li>配置代理对象（是proxyFactoryBean的对象实例）  <ul>
<li>  配置代理接口集</li>
<li>  织入通知</li>
<li>  配置被代理对象</li>
</ul>
</li>
</ul>
</li>
</ul>
  接下来看代码：    <strong>目录结构：</strong>  </li>
</ul>
<img src="https://gitee.com/hqinglau/img/raw/master/img/20210926161526.png" alt="image-20210926161525435" style="zoom:67%;" />  

<p><strong>TestServiceInter.java(interface)</strong></p>
<pre><code class="language-java">package com.nuc.Aop;

public interface TestServiceInter {
    public void sayHello();
}
</code></pre>
<p><strong>TestServiceInter2.java(interface)</strong></p>
<pre><code class="language-java">package com.nuc.Aop;

public interface TestServiceInter2 {
    public void sayBye();
}
</code></pre>
<p><strong>TestService.java</strong></p>
<pre><code class="language-java">package com.nuc.Aop;

public class TestService implements TestServiceInter,TestServiceInter2{
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void sayHello(){
        System.out.println(&quot;hi &quot;+name);
    }

    @Override
    public void sayBye() {
        System.out.println(&quot;bye &quot;+name);
    }
}
</code></pre>
<p><strong>MyMethodBeforeAdvice.java</strong></p>
<pre><code class="language-java">package com.nuc.Aop;

import org.springframework.aop.MethodBeforeAdvice;

import java.lang.reflect.Method;

public class MyMethodBeforeAdvice implements MethodBeforeAdvice {
    //前置通知
    @Override
    public void before(Method method, Object[] objects, Object o)
            throws Throwable {
        //method：被调用方法的名字
        //objects：给method传递的参数
        //o：目标对象
        System.out.println(&quot;记录日志。。。&quot;+method.getName());

    }
}
</code></pre>
<p><strong>beans.xml</strong></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--配置被代理的对象--&gt;
    &lt;bean id=&quot;testService&quot; class=&quot;com.nuc.Aop.TestService&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;sjt&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--配置前置通知--&gt;
    &lt;bean id=&quot;myMethodBeforeAdvice&quot; class=&quot;com.nuc.Aop.MyMethodBeforeAdvice&quot;&gt;&lt;/bean&gt;
    &lt;!--配置代理对象--&gt;
    &lt;bean id=&quot;proxyFactoryBean&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;
        &lt;!--配置代理接口--&gt;
        &lt;property name=&quot;proxyInterfaces&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;com.nuc.Aop.TestServiceInter&lt;/value&gt;
                &lt;value&gt;com.nuc.Aop.TestServiceInter2&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!--把通知织入到代理对象--&gt;
        &lt;property name=&quot;interceptorNames&quot;&gt;
            &lt;!--相当于把myMethodBeforeAdvice前置通知和代理对象关联起来--&gt;
            &lt;value&gt;myMethodBeforeAdvice&lt;/value&gt;
        &lt;/property&gt;
        &lt;!--配置被代理对象,可以指定--&gt;
        &lt;property name=&quot;target&quot; ref=&quot;testService&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p><strong>Test.java</strong></p>
<pre><code class="language-java">package com.nuc.Aop;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
    public static void main(String[] args) {
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;com/nuc/Aop/beans.xml&quot;);
        TestServiceInter testService = (TestServiceInter)ac.getBean(&quot;proxyFactoryBean&quot;);
        testService.sayHello();
        //当一个类继承多个接口，那么他们之间可以互转
        ((TestServiceInter2)testService).sayBye();
    }
}
</code></pre>
<p><strong>测试结果</strong>  </p>
<p><img src="https://gitee.com/hqinglau/img/raw/master/img/20210926161624.png" alt="image-20210926161623795"></p>
<ul>
<li><strong>AOP的术语</strong><ul>
<li>  <strong>切面：</strong>要实现交叉功能，是系统模块化的一个切面领域，如记录日志</li>
<li><strong>连接点：</strong>应用程序执行过程中插入<strong>切面</strong>的地点，可以是方法调用，异常抛出，或者要修改的字段  <ul>
<li>  连接点是一个静态的概念</li>
</ul>
</li>
<li>  <strong>通知：</strong> <strong>切面</strong>的实际实现，它通知系统的新行为，如日志通知包含了实现日志功能的代码，如向日志文件写日志，通知在连接点插入应用系统中。</li>
<li><strong>切入点：</strong>定义了<strong>通知</strong>应该应用在哪些<strong>连接点</strong>，<strong>通知</strong>可以应用到AOP框架支持的任何<strong>连接点</strong>  <ul>
<li>  切入点是动态概念，当通知应用了连接点，连接点就变成了切入点</li>
</ul>
</li>
<li>  <strong>引入：</strong>为类添加新方法和属性</li>
<li>  <strong>目标对象：</strong>被<strong>通知</strong>的对象，既可以是你编写的类，也可以是第三方类</li>
<li><strong>代理：</strong>将<strong>通知</strong>应用到目标对象后创建后的对象，应用系统的其他部分不用为了支持<strong>代理对象</strong>而改变  <ul>
<li>spring的两种代理：  <ul>
<li>  若<strong>目标对象实现了若干个接口，spring使用JDK的java.lang.reflect.Proxy类代理</strong></li>
<li>  若<strong>目标对象没有实现任何接口，spring使用CGLIB库生成目标对象的子类</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>织入：</strong>将<strong>切面</strong>应用到<strong>目标对象</strong>从而创建一个新<strong>代理对象</strong>的过程，织入发生在<strong>目标对象</strong>生命周期的多个点上  <ul>
<li>  <strong>编译期：</strong>切面在目标对象编译时织入，这需要一个特使的编译器</li>
<li>  <strong>类装载期：</strong>切面在目标对象被载入jvm时织入，这需要一个特殊的类加载器</li>
<li>  <strong>运行期：</strong>切面在应用系统运行时切入</li>
</ul>
</li>
</ul>
  接下来引入<strong>后置通知，环绕通知，异常通知，引用通知</strong>  <strong><em>类似于前置通知，前三者需要继承一种接口，引用通知直接配置</em></strong></li>
</ul>
<p><strong>MyAfterReturningAdvice.java</strong></p>
<pre><code class="language-java">package com.nuc.Aop;

import org.springframework.aop.AfterReturningAdvice;

import java.lang.reflect.Method;

public class MyAfterReturningAdvice implements AfterReturningAdvice {
    @Override
    public void afterReturning(Object o, Method method, Object[] objects,
                               Object o1)
            throws Throwable {
        //后置通知
        //o：前面函数的返回值
        //method：哪个方法被调用
        //objects：调用方法的参数
        //o1：目标对象
        System.out.println(&quot;后置通知：调用结束，关闭资源。&quot;);
    }
}
</code></pre>
<p><strong>MyMethodInterceptor.java</strong></p>
<pre><code class="language-java">package com.nuc.Aop;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

public class MyMethodInterceptor implements MethodInterceptor {
    @Override
    public Object invoke(MethodInvocation methodInvocation) throws Throwable {
        //环绕通知
        System.out.println(&quot;环绕通知：进入函数体，调用方法前&quot;);
        Object obj = methodInvocation.proceed();
        System.out.println(&quot;环绕通知：完成调用&quot;);
        return obj;
    }
}
</code></pre>
<p><strong>MyThrowsAdvice.java</strong></p>
<pre><code class="language-java">package com.nuc.Aop;

import org.springframework.aop.ThrowsAdvice;

import java.lang.reflect.Method;

public class MyThrowsAdvice implements ThrowsAdvice {
    //异常通知
    //ThrowsAdvice这个接口是标识性接口，没有任何方法
   public void afterThrowing(Method m,Object[] os,Object target,Exception e){
        System.out.println(&quot;异常通知：出问题了：&quot;+e.getMessage());
    }
}
</code></pre>
<p><strong>beans.xml</strong></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--配置被代理的对象--&gt;
    &lt;bean id=&quot;testService&quot; class=&quot;com.nuc.Aop.TestService&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;sjt&quot;/&gt;
    &lt;/bean&gt;
    &lt;!--配置前置通知--&gt;
    &lt;bean id=&quot;myMethodBeforeAdvice&quot; class=&quot;com.nuc.Aop.MyMethodBeforeAdvice&quot;&gt;&lt;/bean&gt;
    &lt;!--配置后置通知--&gt;
    &lt;bean id=&quot;myAfterReturningAdvice&quot; class=&quot;com.nuc.Aop.MyAfterReturningAdvice&quot;&gt;&lt;/bean&gt;
    &lt;!--配置环绕通知--&gt;
    &lt;bean id=&quot;myMethodInterceptor&quot; class=&quot;com.nuc.Aop.MyMethodInterceptor&quot;&gt;&lt;/bean&gt;
    &lt;!--配置异常通知--&gt;
    &lt;bean id=&quot;myThrowsAdvice&quot; class=&quot;com.nuc.Aop.MyThrowsAdvice&quot;&gt;&lt;/bean&gt;
    &lt;!--定义前置通知的切入点（引用通知）--&gt;
    &lt;bean id=&quot;myMethodBeforeAdviceFilter&quot; class=&quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&gt;
        &lt;property name=&quot;advice&quot; ref=&quot;myMethodBeforeAdvice&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;mappedNames&quot;&gt;
            &lt;list&gt;
                &lt;!--这里支持使用正则表达式匹配--&gt;
                &lt;!--配置了sayHello使用前置通知过滤--&gt;
                &lt;value&gt;sayHello&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;!--配置代理对象--&gt;
    &lt;bean id=&quot;proxyFactoryBean&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;
        &lt;!--配置代理接口--&gt;
        &lt;property name=&quot;proxyInterfaces&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;com.nuc.Aop.TestServiceInter&lt;/value&gt;
                &lt;value&gt;com.nuc.Aop.TestServiceInter2&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!--把通知织入到代理对象--&gt;
        &lt;property name=&quot;interceptorNames&quot;&gt;
            &lt;list&gt;
                &lt;!--相当于把myMethodBeforeAdvice前置通知和代理对象关联起来--&gt;
                &lt;!--使用自定义切入点--&gt;
                &lt;value&gt;myMethodBeforeAdviceFilter&lt;/value&gt;
                &lt;!--织入后置通知--&gt;
                &lt;value&gt;myAfterReturningAdvice&lt;/value&gt;
                &lt;!--织入环绕通知--&gt;
                &lt;value&gt;myMethodInterceptor&lt;/value&gt;
                &lt;!--织入异常通知--&gt;
                &lt;value&gt;myThrowsAdvice&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!--配置被代理对象,可以指定--&gt;
        &lt;property name=&quot;target&quot; ref=&quot;testService&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p><strong>TestService.java</strong>  </p>
<img src="https://gitee.com/hqinglau/img/raw/master/img/20210926161707.png" alt="image-20210926161706203" style="zoom: 50%;" />

<p>  如图这一处变动  </p>
<p>总之呢就是一个配置 -&gt; 织入的过程  </p>
<p><strong>运行结果：</strong>  </p>
<p><img src="https://gitee.com/hqinglau/img/raw/master/img/20210926161729.png" alt="image-20210926161728262">  </p>
<p>可以看到前置通知和后置通知，<strong>似乎能够识别方法</strong>，事实上也是这样的（spring框架内置）。而且sayBay()也得到了应用。<strong>这正是，我们前面所提到了，AOP是对一类或所有对象编程的体现</strong>，又由于异常通知的配置，有了异常，由于引用通知的配置，致使sayBay的前置通知及后续无法通知。  </p>
<p><strong>正常结果（配置引用通知）：</strong>  </p>
<p><img src="https://gitee.com/hqinglau/img/raw/master/img/20210926161752.png" alt="image-20210926161751235"></p>
<h2 id="ps">PS</h2>
<p>报错：</p>
<pre><code class="language-shell">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.
</code></pre>
<p>解决方案：</p>
<p>我原来用的是api，不是simple。</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
    &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
    &lt;version&gt;1.7.25&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="参考">参考</h2>
<p><a href="https://zhuanlan.zhihu.com/p/38208324">BeanPostProcessor —— 连接Spring IOC和AOP的桥梁</a></p>
<p><a href="https://blog.csdn.net/Song_JiangTao/article/details/79949633">Spring核心知识详细教程（已完结）</a></p>
</div>


</div>
<br>
<div id="banquan-yadi" style="display:none">
	<blockquote style="line-height:1.2;padding-bottom:10px;">
		<p>本文地址:
			<a href="https://orzlinux.cn" id="blogaddr-a" style="text-decoration:none; color:black;cursor:pointer;">
				hqinglau的博客</a>
		</p>
		<p>作者:
			<a href="https://orzlinux.cn" style="text-decoration:none; color:black;cursor:pointer;">
				hqinglau
			</a>
		</p>
		<p>博客地址:
			<a href="https://orzlinux.cn" style="text-decoration:none; color:black;cursor:pointer;">
				https://orzlinux.cn
			</a>
		</p>

		<p>版权说明: 如无注明，本文皆由
			<a href="https://orzlinux.cn" style="text-decoration:none; color:black;cursor:pointer;">
				hqinglau
			</a>原创，转载请保留文章出处
		</p>
	</blockquote>
</div>
</article>
</div>
<div id="footer-wrap">
	<div class="copyright">Powered by <a style="color:#4c4948;text-decoration:none;" href="https://github.com/hqinglau/yadihttpd">yadihttpd</a>
		|
			<a style="color:#4c4948;text-decoration:none;" href="https://orzlinux.cn/sitemap.xml">sitemap</a>

		| 
		<a href="https://www.cnzz.com/stat/website.php?web_id=1280379355" style="color:#4c4948;text-decoration:none;" target="_blank" title="站长统计">网站统计</a>
		</div>
	<div class="copyright">Copyright © 2021 hqinglau</div>
	<div style="width:300px;margin:0 auto; padding:5px 0;">
		<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=41022102001049"
			style="display:inline-block;text-decoration:none;height:20px;line-height:20px;"><img
				src="https://orzlinux.cn/img/beian.png" style="float:left;">
			<p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;">豫公网安备
				41022102001049号</p>
		</a>
	</div>
</div>
</div>
<script src="https://cdn.jsdelivr.net/gh/hqinglau/CDN/js/prism.js"></script>

<!-- 看板娘 -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
<script type="text/javascript">document.write(unescape("%3Cspan style='display:none;' id='cnzz_stat_icon_1280379355'%3E%3C/span%3E%3Cscript src='https://s4.cnzz.com/z_stat.php%3Fid%3D1280379355' type='text/javascript'%3E%3C/script%3E"));</script>
<script>
	(function(){
	var el = document.createElement("script");
	el.src = "https://lf1-cdn-tos.bytegoofy.com/goofy/ttzz/push.js?b49908f94659486112caf80ce9c79f8438025d2d666f8d5952ffe1da06a881cb30632485602430134f60bc55ca391050b680e2741bf7233a8f1da9902314a3fa";
	el.id = "ttzz";
	var s = document.getElementsByTagName("script")[0];
	s.parentNode.insertBefore(el, s);
	})(window)
</script>
<script>
	(function(){
	var src = "https://s.ssl.qhres2.com/ssl/ab77b6ea7f3fbf79.js";
	document.write('<script src="' + src + '" id="sozz"><\/script>');
	})();
</script>
<script>
	(function(){
		var bp = document.createElement('script');
		var curProtocol = window.location.protocol.split(':')[0];
		if (curProtocol === 'https'){
	   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
	  }
	  else{
	  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	  }
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(bp, s);
	})();
</script>
				<script type="text/javascript">
				document.getElementById("banquan-yadi").style.display ="";
			document.getElementById("blogaddr-a").href ="https://orzlinux.cn/blog/"+"spring20210926.html";
			document.getElementById("blogaddr-a").innerHTML="spring一";
			</script></body></html> 
